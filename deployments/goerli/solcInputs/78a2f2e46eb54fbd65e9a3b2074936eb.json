{
  "language": "Solidity",
  "sources": {
    "contracts/acl/ACL.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../apps/AragonApp.sol\";\nimport \"../common/ConversionHelpers.sol\";\nimport \"../common/TimeHelpers.sol\";\nimport \"./ACLSyntaxSugar.sol\";\nimport \"./IACL.sol\";\nimport \"./IACLOracle.sol\";\n\n\n/* solium-disable function-order */\n// Allow public initialize() to be first\ncontract ACL is IACL, TimeHelpers, AragonApp, ACLHelpers {\n    /* Hardcoded constants to save gas\n    bytes32 public constant CREATE_PERMISSIONS_ROLE = keccak256(\"CREATE_PERMISSIONS_ROLE\");\n    */\n    bytes32 public constant CREATE_PERMISSIONS_ROLE = 0x0b719b33c83b8e5d300c521cb8b54ae9bd933996a14bef8c2f4e0285d2d2400a;\n\n    enum Op { NONE, EQ, NEQ, GT, LT, GTE, LTE, RET, NOT, AND, OR, XOR, IF_ELSE } // op types\n\n    struct Param {\n        uint8 id;\n        uint8 op;\n        uint240 value; // even though value is an uint240 it can store addresses\n        // in the case of 32 byte hashes losing 2 bytes precision isn't a huge deal\n        // op and id take less than 1 byte each so it can be kept in 1 sstore\n    }\n\n    uint8 internal constant BLOCK_NUMBER_PARAM_ID = 200;\n    uint8 internal constant TIMESTAMP_PARAM_ID    = 201;\n    // 202 is unused\n    uint8 internal constant ORACLE_PARAM_ID       = 203;\n    uint8 internal constant LOGIC_OP_PARAM_ID     = 204;\n    uint8 internal constant PARAM_VALUE_PARAM_ID  = 205;\n    // TODO: Add execution times param type?\n\n    /* Hardcoded constant to save gas\n    bytes32 public constant EMPTY_PARAM_HASH = keccak256(uint256(0));\n    */\n    bytes32 public constant EMPTY_PARAM_HASH = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\n    bytes32 public constant NO_PERMISSION = bytes32(0);\n    address public constant ANY_ENTITY = address(-1);\n    address public constant BURN_ENTITY = address(1); // address(0) is already used as \"no permission manager\"\n\n    string private constant ERROR_AUTH_INIT_KERNEL = \"ACL_AUTH_INIT_KERNEL\";\n    string private constant ERROR_AUTH_NO_MANAGER = \"ACL_AUTH_NO_MANAGER\";\n    string private constant ERROR_EXISTENT_MANAGER = \"ACL_EXISTENT_MANAGER\";\n\n    // Whether someone has a permission\n    mapping (bytes32 => bytes32) internal permissions; // permissions hash => params hash\n    mapping (bytes32 => Param[]) internal permissionParams; // params hash => params\n\n    // Who is the manager of a permission\n    mapping (bytes32 => address) internal permissionManager;\n\n    event SetPermission(address indexed entity, address indexed app, bytes32 indexed role, bool allowed);\n    event SetPermissionParams(address indexed entity, address indexed app, bytes32 indexed role, bytes32 paramsHash);\n    event ChangePermissionManager(address indexed app, bytes32 indexed role, address indexed manager);\n\n    modifier onlyPermissionManager(address _app, bytes32 _role) {\n        require(msg.sender == getPermissionManager(_app, _role), ERROR_AUTH_NO_MANAGER);\n        _;\n    }\n\n    modifier noPermissionManager(address _app, bytes32 _role) {\n        // only allow permission creation (or re-creation) when there is no manager\n        require(getPermissionManager(_app, _role) == address(0), ERROR_EXISTENT_MANAGER);\n        _;\n    }\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initialize an ACL instance and set `_permissionsCreator` as the entity that can create other permissions\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(address _permissionsCreator) public onlyInit {\n        initialized();\n        require(msg.sender == address(kernel()), ERROR_AUTH_INIT_KERNEL);\n\n        _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);\n    }\n\n    /**\n    * @dev Creates a permission that wasn't previously set and managed.\n    *      If a created permission is removed it is possible to reset it with createPermission.\n    *      This is the **ONLY** way to create permissions and set managers to permissions that don't\n    *      have a manager.\n    *      In terms of the ACL being initialized, this function implicitly protects all the other\n    *      state-changing external functions, as they all require the sender to be a manager.\n    * @notice Create a new permission granting `_entity` the ability to perform actions requiring `_role` on `_app`, setting `_manager` as the permission's manager\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _manager Address of the entity that will be able to grant and revoke the permission further.\n    */\n    function createPermission(address _entity, address _app, bytes32 _role, address _manager)\n        external\n        auth(CREATE_PERMISSIONS_ROLE)\n        noPermissionManager(_app, _role)\n    {\n        _createPermission(_entity, _app, _role, _manager);\n    }\n\n    /**\n    * @dev Grants permission if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grant `_entity` the ability to perform actions requiring `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    */\n    function grantPermission(address _entity, address _app, bytes32 _role)\n        external\n    {\n        grantPermissionP(_entity, _app, _role, new uint256[](0));\n    }\n\n    /**\n    * @dev Grants a permission with parameters if allowed. This requires `msg.sender` to be the permission manager\n    * @notice Grant `_entity` the ability to perform actions requiring `_role` on `_app`\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app in which the role will be allowed (requires app to depend on kernel for ACL)\n    * @param _role Identifier for the group of actions in app given access to perform\n    * @param _params Permission parameters\n    */\n    function grantPermissionP(address _entity, address _app, bytes32 _role, uint256[] _params)\n        public\n        onlyPermissionManager(_app, _role)\n    {\n        bytes32 paramsHash = _params.length > 0 ? _saveParams(_params) : EMPTY_PARAM_HASH;\n        _setPermission(_entity, _app, _role, paramsHash);\n    }\n\n    /**\n    * @dev Revokes permission if allowed. This requires `msg.sender` to be the the permission manager\n    * @notice Revoke from `_entity` the ability to perform actions requiring `_role` on `_app`\n    * @param _entity Address of the whitelisted entity to revoke access from\n    * @param _app Address of the app in which the role will be revoked\n    * @param _role Identifier for the group of actions in app being revoked\n    */\n    function revokePermission(address _entity, address _app, bytes32 _role)\n        external\n        onlyPermissionManager(_app, _role)\n    {\n        _setPermission(_entity, _app, _role, NO_PERMISSION);\n    }\n\n    /**\n    * @notice Set `_newManager` as the manager of `_role` in `_app`\n    * @param _newManager Address for the new manager\n    * @param _app Address of the app in which the permission management is being transferred\n    * @param _role Identifier for the group of actions being transferred\n    */\n    function setPermissionManager(address _newManager, address _app, bytes32 _role)\n        external\n        onlyPermissionManager(_app, _role)\n    {\n        _setPermissionManager(_newManager, _app, _role);\n    }\n\n    /**\n    * @notice Remove the manager of `_role` in `_app`\n    * @param _app Address of the app in which the permission is being unmanaged\n    * @param _role Identifier for the group of actions being unmanaged\n    */\n    function removePermissionManager(address _app, bytes32 _role)\n        external\n        onlyPermissionManager(_app, _role)\n    {\n        _setPermissionManager(address(0), _app, _role);\n    }\n\n    /**\n    * @notice Burn non-existent `_role` in `_app`, so no modification can be made to it (grant, revoke, permission manager)\n    * @param _app Address of the app in which the permission is being burned\n    * @param _role Identifier for the group of actions being burned\n    */\n    function createBurnedPermission(address _app, bytes32 _role)\n        external\n        auth(CREATE_PERMISSIONS_ROLE)\n        noPermissionManager(_app, _role)\n    {\n        _setPermissionManager(BURN_ENTITY, _app, _role);\n    }\n\n    /**\n    * @notice Burn `_role` in `_app`, so no modification can be made to it (grant, revoke, permission manager)\n    * @param _app Address of the app in which the permission is being burned\n    * @param _role Identifier for the group of actions being burned\n    */\n    function burnPermissionManager(address _app, bytes32 _role)\n        external\n        onlyPermissionManager(_app, _role)\n    {\n        _setPermissionManager(BURN_ENTITY, _app, _role);\n    }\n\n    /**\n     * @notice Get parameters for permission array length\n     * @param _entity Address of the whitelisted entity that will be able to perform the role\n     * @param _app Address of the app\n     * @param _role Identifier for a group of actions in app\n     * @return Length of the array\n     */\n    function getPermissionParamsLength(address _entity, address _app, bytes32 _role) external view returns (uint) {\n        return permissionParams[permissions[permissionHash(_entity, _app, _role)]].length;\n    }\n\n    /**\n    * @notice Get parameter for permission\n    * @param _entity Address of the whitelisted entity that will be able to perform the role\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @param _index Index of parameter in the array\n    * @return Parameter (id, op, value)\n    */\n    function getPermissionParam(address _entity, address _app, bytes32 _role, uint _index)\n        external\n        view\n        returns (uint8, uint8, uint240)\n    {\n        Param storage param = permissionParams[permissions[permissionHash(_entity, _app, _role)]][_index];\n        return (param.id, param.op, param.value);\n    }\n\n    /**\n    * @dev Get manager for permission\n    * @param _app Address of the app\n    * @param _role Identifier for a group of actions in app\n    * @return address of the manager for the permission\n    */\n    function getPermissionManager(address _app, bytes32 _role) public view returns (address) {\n        return permissionManager[roleHash(_app, _role)];\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission statu\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _where Identifier for a group of actions in app\n    * @param _how Permission parameters\n    * @return boolean indicating whether the ACL allows the role or not\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes memory _how) public view returns (bool) {\n        return hasPermission(_who, _where, _what, ConversionHelpers.dangerouslyCastBytesToUintArray(_how));\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what, uint256[] memory _how) public view returns (bool) {\n        bytes32 whoParams = permissions[permissionHash(_who, _where, _what)];\n        if (whoParams != NO_PERMISSION && evalParams(whoParams, _who, _where, _what, _how)) {\n            return true;\n        }\n\n        bytes32 anyParams = permissions[permissionHash(ANY_ENTITY, _where, _what)];\n        if (anyParams != NO_PERMISSION && evalParams(anyParams, ANY_ENTITY, _where, _what, _how)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function hasPermission(address _who, address _where, bytes32 _what) public view returns (bool) {\n        uint256[] memory empty = new uint256[](0);\n        return hasPermission(_who, _where, _what, empty);\n    }\n\n    function evalParams(\n        bytes32 _paramsHash,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) public view returns (bool)\n    {\n        if (_paramsHash == EMPTY_PARAM_HASH) {\n            return true;\n        }\n\n        return _evalParam(_paramsHash, 0, _who, _where, _what, _how);\n    }\n\n    /**\n    * @dev Internal createPermission for access inside the kernel (on instantiation)\n    */\n    function _createPermission(address _entity, address _app, bytes32 _role, address _manager) internal {\n        _setPermission(_entity, _app, _role, EMPTY_PARAM_HASH);\n        _setPermissionManager(_manager, _app, _role);\n    }\n\n    /**\n    * @dev Internal function called to actually save the permission\n    */\n    function _setPermission(address _entity, address _app, bytes32 _role, bytes32 _paramsHash) internal {\n        permissions[permissionHash(_entity, _app, _role)] = _paramsHash;\n        bool entityHasPermission = _paramsHash != NO_PERMISSION;\n        bool permissionHasParams = entityHasPermission && _paramsHash != EMPTY_PARAM_HASH;\n\n        emit SetPermission(_entity, _app, _role, entityHasPermission);\n        if (permissionHasParams) {\n            emit SetPermissionParams(_entity, _app, _role, _paramsHash);\n        }\n    }\n\n    function _saveParams(uint256[] _encodedParams) internal returns (bytes32) {\n        bytes32 paramHash = keccak256(abi.encodePacked(_encodedParams));\n        Param[] storage params = permissionParams[paramHash];\n\n        if (params.length == 0) { // params not saved before\n            for (uint256 i = 0; i < _encodedParams.length; i++) {\n                uint256 encodedParam = _encodedParams[i];\n                Param memory param = Param(decodeParamId(encodedParam), decodeParamOp(encodedParam), uint240(encodedParam));\n                params.push(param);\n            }\n        }\n\n        return paramHash;\n    }\n\n    function _evalParam(\n        bytes32 _paramsHash,\n        uint32 _paramId,\n        address _who,\n        address _where,\n        bytes32 _what,\n        uint256[] _how\n    ) internal view returns (bool)\n    {\n        if (_paramId >= permissionParams[_paramsHash].length) {\n            return false; // out of bounds\n        }\n\n        Param memory param = permissionParams[_paramsHash][_paramId];\n\n        if (param.id == LOGIC_OP_PARAM_ID) {\n            return _evalLogic(param, _paramsHash, _who, _where, _what, _how);\n        }\n\n        uint256 value;\n        uint256 comparedTo = uint256(param.value);\n\n        // get value\n        if (param.id == ORACLE_PARAM_ID) {\n            value = checkOracle(IACLOracle(param.value), _who, _where, _what, _how) ? 1 : 0;\n            comparedTo = 1;\n        } else if (param.id == BLOCK_NUMBER_PARAM_ID) {\n            value = getBlockNumber();\n        } else if (param.id == TIMESTAMP_PARAM_ID) {\n            value = getTimestamp();\n        } else if (param.id == PARAM_VALUE_PARAM_ID) {\n            value = uint256(param.value);\n        } else {\n            if (param.id >= _how.length) {\n                return false;\n            }\n            value = uint256(uint240(_how[param.id])); // force lost precision\n        }\n\n        if (Op(param.op) == Op.RET) {\n            return uint256(value) > 0;\n        }\n\n        return compare(value, Op(param.op), comparedTo);\n    }\n\n    function _evalLogic(Param _param, bytes32 _paramsHash, address _who, address _where, bytes32 _what, uint256[] _how)\n        internal\n        view\n        returns (bool)\n    {\n        if (Op(_param.op) == Op.IF_ELSE) {\n            uint32 conditionParam;\n            uint32 successParam;\n            uint32 failureParam;\n\n            (conditionParam, successParam, failureParam) = decodeParamsList(uint256(_param.value));\n            bool result = _evalParam(_paramsHash, conditionParam, _who, _where, _what, _how);\n\n            return _evalParam(_paramsHash, result ? successParam : failureParam, _who, _where, _what, _how);\n        }\n\n        uint32 param1;\n        uint32 param2;\n\n        (param1, param2,) = decodeParamsList(uint256(_param.value));\n        bool r1 = _evalParam(_paramsHash, param1, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.NOT) {\n            return !r1;\n        }\n\n        if (r1 && Op(_param.op) == Op.OR) {\n            return true;\n        }\n\n        if (!r1 && Op(_param.op) == Op.AND) {\n            return false;\n        }\n\n        bool r2 = _evalParam(_paramsHash, param2, _who, _where, _what, _how);\n\n        if (Op(_param.op) == Op.XOR) {\n            return r1 != r2;\n        }\n\n        return r2; // both or and and depend on result of r2 after checks\n    }\n\n    function compare(uint256 _a, Op _op, uint256 _b) internal pure returns (bool) {\n        if (_op == Op.EQ)  return _a == _b;                              // solium-disable-line lbrace\n        if (_op == Op.NEQ) return _a != _b;                              // solium-disable-line lbrace\n        if (_op == Op.GT)  return _a > _b;                               // solium-disable-line lbrace\n        if (_op == Op.LT)  return _a < _b;                               // solium-disable-line lbrace\n        if (_op == Op.GTE) return _a >= _b;                              // solium-disable-line lbrace\n        if (_op == Op.LTE) return _a <= _b;                              // solium-disable-line lbrace\n        return false;\n    }\n\n    function checkOracle(IACLOracle _oracleAddr, address _who, address _where, bytes32 _what, uint256[] _how) internal view returns (bool) {\n        bytes4 sig = _oracleAddr.canPerform.selector;\n\n        // a raw call is required so we can return false if the call reverts, rather than reverting\n        bytes memory checkCalldata = abi.encodeWithSelector(sig, _who, _where, _what, _how);\n\n        bool ok;\n        assembly {\n            // send all available gas; if the oracle eats up all the gas, we will eventually revert\n            // note that we are currently guaranteed to still have some gas after the call from\n            // EIP-150's 63/64 gas forward rule\n            ok := staticcall(gas, _oracleAddr, add(checkCalldata, 0x20), mload(checkCalldata), 0, 0)\n        }\n\n        if (!ok) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := returndatasize }\n        if (size != 32) {\n            return false;\n        }\n\n        bool result;\n        assembly {\n            let ptr := mload(0x40)       // get next free memory ptr\n            returndatacopy(ptr, 0, size) // copy return from above `staticcall`\n            result := mload(ptr)         // read data at ptr and set it to result\n            mstore(ptr, 0)               // set pointer memory to 0 so it still is the next free ptr\n        }\n\n        return result;\n    }\n\n    /**\n    * @dev Internal function that sets management\n    */\n    function _setPermissionManager(address _newManager, address _app, bytes32 _role) internal {\n        permissionManager[roleHash(_app, _role)] = _newManager;\n        emit ChangePermissionManager(_app, _role, _newManager);\n    }\n\n    function roleHash(address _where, bytes32 _what) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"ROLE\", _where, _what));\n    }\n\n    function permissionHash(address _who, address _where, bytes32 _what) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"PERMISSION\", _who, _where, _what));\n    }\n}\n"
    },
    "contracts/apps/AragonApp.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./AppStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../common/Autopetrified.sol\";\nimport \"../common/ConversionHelpers.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\n\n\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\n// that they can never be initialized.\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\n// are included so that they are automatically usable by subclassing contracts\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\n    string private constant ERROR_AUTH_FAILED = \"APP_AUTH_FAILED\";\n\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] _params) {\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    /**\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\n    * @param _sender Sender of the call\n    * @param _role Role on this app\n    * @param _params Permission params for the role\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\n    *         Always returns false if the app hasn't been initialized yet.\n    */\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }\n\n    /**\n    * @dev Get the recovery vault for the app\n    * @return Recovery vault address for the app\n    */\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n    }\n}\n"
    },
    "contracts/common/ConversionHelpers.sol": {
      "content": "pragma solidity ^0.4.24;\n\n\nlibrary ConversionHelpers {\n    string private constant ERROR_IMPROPER_LENGTH = \"CONVERSION_IMPROPER_LENGTH\";\n\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n        // Force cast the uint256[] into a bytes array, by overwriting its length\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 byteLength = _input.length * 32;\n        assembly {\n            output := _input\n            mstore(output, byteLength)\n        }\n    }\n\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n        // Force cast the bytes array into a uint256[], by overwriting its length\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 intsLength = _input.length / 32;\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n\n        assembly {\n            output := _input\n            mstore(output, intsLength)\n        }\n    }\n}\n"
    },
    "contracts/common/TimeHelpers.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Uint256Helpers.sol\";\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"
    },
    "contracts/acl/ACLSyntaxSugar.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"
    },
    "contracts/acl/IACL.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"
    },
    "contracts/acl/IACLOracle.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IACLOracle {\n    function canPerform(address who, address where, bytes32 what, uint256[] how) external view returns (bool);\n}\n"
    },
    "contracts/apps/AppStorage.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256(\"aragonOS.appStorage.kernel\");\n    bytes32 internal constant APP_ID_POSITION = keccak256(\"aragonOS.appStorage.appId\");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}\n"
    },
    "contracts/common/Autopetrified.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Petrifiable.sol\";\n\n\ncontract Autopetrified is Petrifiable {\n    constructor() public {\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\n        // This renders them uninitializable (and unusable without a proxy).\n        petrify();\n    }\n}\n"
    },
    "contracts/common/ReentrancyGuard.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\n\n\ncontract ReentrancyGuard {\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\"aragonOS.reentrancyGuard.mutex\");\n    */\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\n\n    string private constant ERROR_REENTRANT = \"REENTRANCY_REENTRANT_CALL\";\n\n    modifier nonReentrant() {\n        // Ensure mutex is unlocked\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\n\n        // Lock mutex before function call\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\n\n        // Perform function call\n        _;\n\n        // Unlock mutex after function call\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\n    }\n}\n"
    },
    "contracts/common/VaultRecoverable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../lib/token/ERC20.sol\";\nimport \"./EtherTokenConstant.sol\";\nimport \"./IsContract.sol\";\nimport \"./IVaultRecoverable.sol\";\nimport \"./SafeERC20.sol\";\n\n\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_DISALLOWED = \"RECOVER_DISALLOWED\";\n    string private constant ERROR_VAULT_NOT_CONTRACT = \"RECOVER_VAULT_NOT_CONTRACT\";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"RECOVER_TOKEN_TRANSFER_FAILED\";\n\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n\n    // Cast non-implemented interface to be public so we can use it internally\n    function getRecoveryVault() public view returns (address);\n}\n"
    },
    "contracts/evmscript/EVMScriptRunner.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AppStorage.sol\";\nimport \"../kernel/KernelConstants.sol\";\nimport \"../common/Initializable.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \"EVMRUN_EXECUTOR_UNAVAILABLE\";\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \"EVMRUN_PROTECTED_STATE_MODIFIED\";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \"EVMRUN_EXECUTOR_INVALID_RETURN\";\n    */\n\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }\n\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don't write output (we'll handle this ourselves)\n                0                   // don't write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with \"EVMRUN_EXECUTOR_INVALID_RETURN\"\n                    // See remix: doing a `revert(\"EVMRUN_EXECUTOR_INVALID_RETURN\")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }\n\n    modifier protectState {\n        address preKernel = address(kernel());\n        bytes32 preAppId = appId();\n        _; // exec\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n    }\n}\n"
    },
    "contracts/common/UnstructuredStorage.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\nlibrary UnstructuredStorage {\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}\n"
    },
    "contracts/kernel/IKernel.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../acl/IACL.sol\";\nimport \"../common/IVaultRecoverable.sol\";\n\n\ninterface IKernelEvents {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\n}\n\n\n// This should be an interface, but interfaces can't inherit yet :(\ncontract IKernel is IKernelEvents, IVaultRecoverable {\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}\n"
    },
    "contracts/common/IVaultRecoverable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IVaultRecoverable {\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) external view returns (bool);\n    function getRecoveryVault() external view returns (address);\n}\n"
    },
    "contracts/common/Petrifiable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Initializable.sol\";\n\n\ncontract Petrifiable is Initializable {\n    // Use block UINT256_MAX (which should be never) as the initializable date\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\n\n    function isPetrified() public view returns (bool) {\n        return getInitializationBlock() == PETRIFIED_BLOCK;\n    }\n\n    /**\n    * @dev Function to be called by top level contract to prevent being initialized.\n    *      Useful for freezing base contracts when they're used behind proxies.\n    */\n    function petrify() internal onlyInit {\n        initializedAt(PETRIFIED_BLOCK);\n    }\n}\n"
    },
    "contracts/common/Initializable.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./TimeHelpers.sol\";\nimport \"./UnstructuredStorage.sol\";\n\n\ncontract Initializable is TimeHelpers {\n    using UnstructuredStorage for bytes32;\n\n    // keccak256(\"aragonOS.initializable.initializationBlock\")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\n    string private constant ERROR_NOT_INITIALIZED = \"INIT_NOT_INITIALIZED\";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}\n"
    },
    "contracts/common/Uint256Helpers.sol": {
      "content": "pragma solidity ^0.4.24;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n"
    },
    "contracts/lib/token/ERC20.sol": {
      "content": "// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/common/EtherTokenConstant.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\n// contracts where both tokens and ETH are accepted\ncontract EtherTokenConstant {\n    address internal constant ETH = address(0);\n}\n"
    },
    "contracts/common/IsContract.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract IsContract {\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"
    },
    "contracts/common/SafeERC20.sol": {
      "content": "// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\n\npragma solidity ^0.4.24;\n\nimport \"../lib/token/ERC20.sol\";\n\n\nlibrary SafeERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}\n"
    },
    "contracts/evmscript/IEVMScriptExecutor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n    function executorType() external pure returns (bytes32);\n}\n"
    },
    "contracts/evmscript/IEVMScriptRegistry.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./IEVMScriptExecutor.sol\";\n\n\ncontract EVMScriptRegistryConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\n    */\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n}\n"
    },
    "contracts/kernel/KernelConstants.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract KernelAppIds {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\"kernel\");\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\"acl\");\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\"vault\");\n    */\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\n}\n\n\ncontract KernelNamespaceConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\"app\");\n    */\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n}\n"
    },
    "contracts/test/tests/TestACLInterpreter.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../acl/ACL.sol\";\nimport \"../helpers/Assert.sol\";\nimport \"../helpers/ACLHelper.sol\";\n\n\ncontract TestACLInterpreter is ACL, ACLHelper {\n    function testEqualityUint() public {\n        // Assert param 0 is equal to 10, given that params are [10, 11]\n        assertEval(arr(uint256(10), 11), 0, Op.EQ, 10, true);\n        assertEval(arr(uint256(10), 11), 1, Op.EQ, 10, false);\n        assertEval(arr(uint256(10), 11), 1, Op.EQ, 11, true);\n    }\n\n    function testEqualityAddr() public {\n        assertEval(arr(msg.sender), 0, Op.EQ, uint256(msg.sender), true);\n        assertEval(arr(msg.sender), 0, Op.EQ, uint256(this), false);\n    }\n\n    function testEqualityBytes() public {\n        assertEval(arr(keccak256(\"hi\")), 0, Op.EQ, uint256(keccak256(\"hi\")), true);\n        assertEval(arr(keccak256(\"hi\")), 0, Op.EQ, uint256(keccak256(\"bye\")), false);\n    }\n\n    function testInequalityUint() public {\n        assertEval(arr(uint256(10), 11), 0, Op.NEQ, 10, false);\n        assertEval(arr(uint256(10), 11), 1, Op.NEQ, 10, true);\n        assertEval(arr(uint256(10), 11), 1, Op.NEQ, 11, false);\n    }\n\n    function testInequalityBytes() public {\n        assertEval(arr(keccak256(\"hi\")), 0, Op.NEQ, uint256(keccak256(\"hi\")), false);\n        assertEval(arr(keccak256(\"hi\")), 0, Op.NEQ, uint256(keccak256(\"bye\")), true);\n    }\n\n    function testInequalityAddr() public {\n        assertEval(arr(msg.sender), 0, Op.NEQ, uint256(msg.sender), false);\n        assertEval(arr(msg.sender), 0, Op.NEQ, uint256(this), true);\n    }\n\n    function testGreatherThan() public {\n        assertEval(arr(uint256(10), 11), 0, Op.GT, 9, true);\n        assertEval(arr(uint256(10), 11), 0, Op.GT, 10, false);\n        assertEval(arr(uint256(10), 11), 1, Op.GT, 10, true);\n    }\n\n    function testLessThan() public {\n        assertEval(arr(uint256(10), 11), 0, Op.LT, 9, false);\n        assertEval(arr(uint256(9), 11), 0, Op.LT, 10, true);\n        assertEval(arr(uint256(10), 11), 1, Op.LT, 10, false);\n    }\n\n    function testGreatherThanOrEqual() public {\n        assertEval(arr(uint256(10), 11), 0, Op.GTE, 9, true);\n        assertEval(arr(uint256(10), 11), 0, Op.GTE, 10, true);\n        assertEval(arr(uint256(10), 11), 1, Op.GTE, 12, false);\n    }\n\n    function testLessThanOrEqual() public {\n        assertEval(arr(uint256(10), 11), 0, Op.LTE, 9, false);\n        assertEval(arr(uint256(9), 11), 0, Op.LTE, 10, true);\n        assertEval(arr(uint256(10), 11), 1, Op.LTE, 11, true);\n    }\n\n    function testTimestamp() public {\n        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.EQ, uint256(block.timestamp), true);\n        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.EQ, uint256(1), false);\n        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.GT, uint256(1), true);\n    }\n\n    function testBlockNumber() public {\n        assertEval(arr(), BLOCK_NUMBER_PARAM_ID, Op.EQ, uint256(block.number), true);\n        assertEval(arr(), BLOCK_NUMBER_PARAM_ID, Op.EQ, uint256(1), false);\n        assertEval(arr(), BLOCK_NUMBER_PARAM_ID, Op.GT, uint256(block.number - 1), true);\n    }\n\n    function testOracle() public {\n        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new AcceptOracle()), true);\n        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new RejectOracle()), false);\n        assertEval(arr(), ORACLE_PARAM_ID, Op.NEQ, uint256(new RejectOracle()), true);\n\n        // doesn't revert even if oracle reverts\n        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new RevertOracle()), false);\n        // if returned data size is not correct, returns false\n        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new EmptyDataReturnOracle()), false);\n\n        // conditional oracle returns true if first param > 0\n        ConditionalOracle conditionalOracle = new ConditionalOracle();\n\n        assertEval(arr(uint256(1)), ORACLE_PARAM_ID, Op.EQ, uint256(conditionalOracle), true);\n        assertEval(arr(uint256(0), uint256(1)), ORACLE_PARAM_ID, Op.EQ, uint256(conditionalOracle), false);\n    }\n\n    function testReturn() public {\n        assertEval(arr(), PARAM_VALUE_PARAM_ID, Op.RET, uint256(1), true);\n        assertEval(arr(), PARAM_VALUE_PARAM_ID, Op.RET, uint256(0), false);\n        assertEval(arr(), PARAM_VALUE_PARAM_ID, Op.RET, uint256(100), true);\n        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.RET, uint256(0), true);\n    }\n\n    function testNot() public {\n        Param memory retTrue = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);\n        Param memory retFalse = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);\n\n        Param memory notOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.NOT), encodeOperator(1, 0));\n        Param[] memory params = new Param[](2);\n\n        // !true == false\n        params[0] = notOp;\n        params[1] = retTrue;\n        assertEval(params, false);\n\n        // !false == true\n        params[1] = retFalse;\n        assertEval(params, true);\n    }\n\n    function testComplexCombination() public {\n        // if (oracle and block number > block number - 1) then arg 0 < 10 or oracle else false\n        Param[] memory params = new Param[](7);\n        params[0] = Param(LOGIC_OP_PARAM_ID, uint8(Op.IF_ELSE), encodeIfElse(1, 4, 6));\n        params[1] = Param(LOGIC_OP_PARAM_ID, uint8(Op.AND), encodeOperator(2, 3));\n        params[2] = Param(ORACLE_PARAM_ID, uint8(Op.EQ), uint240(new AcceptOracle()));\n        params[3] = Param(BLOCK_NUMBER_PARAM_ID, uint8(Op.GT), uint240(block.number - 1));\n        params[4] = Param(LOGIC_OP_PARAM_ID, uint8(Op.OR), encodeOperator(5, 2));\n        params[5] = Param(0, uint8(Op.LT), uint240(10));\n        params[6] = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);\n\n        assertEval(params, arr(uint256(10)), true);\n\n        params[4] = Param(LOGIC_OP_PARAM_ID, uint8(Op.AND), encodeOperator(5, 2));\n        assertEval(params, arr(uint256(10)), false);\n    }\n\n    function testParamOutOfBoundsFail() public {\n        Param[] memory params = new Param[](2);\n\n        params[1] = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);\n        assertEval(params, arr(uint256(10)), false);\n\n        params[0] = Param(LOGIC_OP_PARAM_ID, uint8(Op.IF_ELSE), encodeIfElse(2, 2, 2));\n        assertEval(params, arr(uint256(10)), false);\n    }\n\n    function testArgOutOfBoundsFail() public {\n        assertEval(arr(uint256(10), 11), 3, Op.EQ, 10, false);\n    }\n\n    function testIfElse() public {\n        Param memory retTrue = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);\n        Param memory retFalse = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);\n\n        // If 1 then 2 else 3\n        Param memory ifOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.IF_ELSE), encodeIfElse(1, 2, 3));\n        Param[] memory params = new Param[](4);\n\n        // true ? true : false == true\n        params[0] = ifOp;\n        params[1] = retTrue;\n        params[2] = retTrue;\n        params[3] = retFalse;\n        assertEval(params, true);\n\n        // false ? true : false == false\n        params[1] = retFalse;\n        assertEval(params, false);\n    }\n\n    function testCombinators() public {\n        Param memory retTrue = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);\n        Param memory retFalse = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);\n\n        // OR param at index 1 or param 2\n        Param memory orOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.OR), encodeOperator(1, 2));\n        Param memory andOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.AND), encodeOperator(1, 2));\n        Param memory xorOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.XOR), encodeOperator(1, 2));\n\n        Param[] memory params = new Param[](3);\n\n        // or true true == true\n        params[0] = orOp;\n        params[1] = retTrue;\n        params[2] = retTrue;\n        assertEval(params, true);\n\n        // or false true == true\n        params[1] = retFalse;\n        assertEval(params, true);\n\n        // or true false == true\n        params[1] = retTrue;\n        params[2] = retFalse;\n        assertEval(params, true);\n\n        // or false false == false\n        params[1] = retFalse;\n        assertEval(params, false);\n\n        // and false false == false\n        params[0] = andOp;\n        assertEval(params, false);\n\n        // and true false == false\n        params[1] = retTrue;\n        assertEval(params, false);\n\n        // and false true == false\n        params[1] = retFalse;\n        params[2] = retTrue;\n        assertEval(params, false);\n\n        // and true true == true\n        params[1] = retTrue;\n        params[2] = retTrue;\n        assertEval(params, true);\n\n        // xor true true == false\n        params[0] = xorOp;\n        assertEval(params, false);\n\n        // xor false true == true\n        params[1] = retFalse;\n        assertEval(params, true);\n\n        // xor true false == true\n        params[1] = retTrue;\n        params[2] = retFalse;\n        assertEval(params, true);\n\n        // xor false false == false\n        params[1] = retFalse;\n        assertEval(params, false);\n    }\n\n\n    function assertEval(uint256[] memory args, uint8 argId, Op op, uint256 value, bool expected) internal {\n        Param[] memory params = new Param[](1);\n        params[0] = Param(argId, uint8(op), uint240(value));\n        assertEval(params, args, expected);\n    }\n\n    function assertEval(Param[] memory params, bool expected) internal {\n        assertEval(params, new uint256[](0), expected);\n    }\n\n    function assertEval(Param[] memory params, uint256[] memory args, bool expected) internal {\n        bytes32 paramHash = encodeAndSaveParams(params);\n        bool allow = _evalParam(paramHash, 0, address(0), address(0), bytes32(0), args);\n\n        Assert.equal(allow, expected, \"eval got unexpected result\");\n    }\n\n    event LogParam(bytes32 param);\n    function encodeAndSaveParams(Param[] memory params) internal returns (bytes32) {\n        uint256[] memory encodedParams = new uint256[](params.length);\n\n        for (uint256 i = 0; i < params.length; i++) {\n            Param memory param = params[i];\n            encodedParams[i] = (uint256(param.id) << 248) + (uint256(param.op) << 240) + param.value;\n            emit LogParam(bytes32(encodedParams[i]));\n        }\n\n        return _saveParams(encodedParams);\n    }\n}\n"
    },
    "contracts/test/helpers/Assert.sol": {
      "content": "// Taken from https://github.com/trufflesuite/truffle/blob/ef03be9e35909e5e7c97a9ecb07ccae4872645ca/packages/truffle-core/lib/testing/Assert.sol\n\npragma solidity ^0.4.17;\n\n/*\n    File: Assertions.slb\n    Author: Andreas Olofsson (androlo1980@gmail.com)\n    Library: Assertions\n    Assertions for unit testing contracts. Tests are run with the\n    <solUnit at https://github.com/smartcontractproduction/sol-unit>\n    unit-testing framework.\n    (start code)\n    contract ModAdder {\n        function addMod(uint a, uint b, uint modulus) constant returns (uint sum) {\n            if (modulus == 0)\n                throw;\n            return addmod(a, b, modulus);\n        }\n    }\n    contract SomeTest {\n        using Assertions for uint;\n        function testAdd() {\n            var adder = new ModAdder();\n            adder.addMod(50, 66, 30).equal(26, \"addition returned the wrong sum\");\n        }\n    }\n    (end)\n    It is also possible to extend <Test>, to have all bindings (using) properly set up.\n    (start code)\n    contract SomeTest is Test {\n        function testAdd() {\n            var adder = new ModAdder();\n            adder.addMod(50, 66, 30).equal(26, \"addition returned the wrong sum\");\n        }\n    }\n    (end)\n*/\nlibrary Assert {\n\n    // Constant: ADDRESS_NULL\n    // The null address: 0\n    address constant ADDRESS_NULL = 0x0000000000000000000000000000000000000000;\n    // Constant: BYTES32_NULL\n    // The null bytes32: 0\n    bytes32 constant BYTES32_NULL = 0x0;\n    // Constant: STRING_NULL\n    // The null string: \"\"\n    string constant STRING_NULL = \"\";\n\n    uint8 constant ZERO = uint8(byte('0'));\n    uint8 constant A = uint8(byte('a'));\n\n    byte constant MINUS = byte('-');\n\n    /*\n        Event: TestEvent\n        Fired when an assertion is made.\n        Params:\n            result (bool) - Whether or not the assertion holds.\n            message (string) - A message to display if the assertion does not hold.\n    */\n    event TestEvent(bool indexed result, string message);\n\n    // ************************************** general **************************************\n\n    /*\n        Function: fail()\n        Mark the test as failed.\n        Params:\n            message (string) - A message associated with the failure.\n        Returns:\n            result (bool) - false.\n    */\n    function fail(string message) public returns (bool result) {\n        _report(false, message);\n        return false;\n    }\n\n    // ************************************** strings **************************************\n\n    /*\n        Function: equal(string)\n        Assert that two strings are equal.\n        : _stringsEqual(A, B) == true\n        Params:\n            A (string) - The first string.\n            B (string) - The second string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(string a, string b, string message) public returns (bool result) {\n        result = _stringsEqual(a, b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: notEqual(string)\n        Assert that two strings are not equal.\n        : _stringsEqual(A, B) == false\n        Params:\n            A (string) - The first string.\n            B (string) - The second string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(string a, string b, string message) public returns (bool result) {\n        result = !_stringsEqual(a, b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isEmpty(string)\n        Assert that a string is empty.\n        : _stringsEqual(str, STRING_NULL) == true\n        Params:\n            str (string) - The string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isEmpty(string str, string message) public returns (bool result) {\n        result = _stringsEqual(str, STRING_NULL);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(str, \"Tested\"), message));\n    }\n\n    /*\n        Function: isNotEmpty(string)\n        Assert that a string is not empty.\n        : _stringsEqual(str, STRING_NULL) == false\n        Params:\n            str (string) - The string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isNotEmpty(string str, string message) public returns (bool result) {\n        result = !_stringsEqual(str, STRING_NULL);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(str, \"Tested\"), message));\n    }\n\n    // ************************************** bytes32 **************************************\n\n    /*\n        Function: equal(bytes32)\n        Assert that two 'bytes32' are equal.\n        : A == B\n        Params:\n            A (bytes32) - The first 'bytes32'.\n            B (bytes32) - The second 'bytes32'.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(bytes32 a, bytes32 b, string message) public returns (bool result) {\n        result = (a == b);\n        _report(result, message);\n    }\n\n    /*\n        Function: notEqual(bytes32)\n        Assert that two 'bytes32' are not equal.\n        : A != B\n        Params:\n            A (bytes32) - The first 'bytes32'.\n            B (bytes32) - The second 'bytes32'.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(bytes32 a, bytes32 b, string message) public returns (bool result) {\n        result = (a != b);\n        _report(result, message);\n    }\n\n    /*\n        Function: isZero(bytes32)\n        Assert that a 'bytes32' is zero.\n        : bts == BYTES32_NULL\n        Params:\n            bts (bytes32) - The 'bytes32'.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isZero(bytes32 bts, string message) public returns (bool result) {\n        result = (bts == BYTES32_NULL);\n        _report(result, message);\n    }\n\n    /*\n        Function: isNotZero(bytes32)\n        Assert that a 'bytes32' is not zero.\n        : bts != BYTES32_NULL\n        Params:\n            bts (bytes32) - The 'bytes32'.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isNotZero(bytes32 bts, string message) public returns (bool result) {\n        result = (bts != BYTES32_NULL);\n        _report(result, message);\n    }\n\n    // ************************************** address **************************************\n\n    /*\n        Function: equal(address)\n        Assert that two addresses are equal.\n        : A == B\n        Params:\n            A (address) - The first address.\n            B (address) - The second address.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(address a, address b, string message) public returns (bool result) {\n        result = (a == b);\n        _report(result, message);\n    }\n    /*\n        Function: notEqual(address)\n        Assert that two addresses are not equal.\n        : A != B\n        Params:\n            A (address) - The first address.\n            B (address) - The second address.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(address a, address b, string message) public returns (bool result) {\n        result = (a != b);\n         _report(result, message);\n    }\n\n    /*\n        Function: isZero(address)\n        Assert that an address is zero.\n        : addr == ADDRESS_NULL\n        Params:\n            addr (address) - The address.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isZero(address addr, string message) public returns (bool result) {\n        result = (addr == ADDRESS_NULL);\n        _report(result, message);\n    }\n\n    /*\n        Function: isNotZero(address)\n        Assert that an address is not zero.\n        : addr != ADDRESS_NULL\n        Params:\n            addr (address) - The address.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isNotZero(address addr, string message) public returns (bool result) {\n        result = (addr != ADDRESS_NULL);\n        _report(result, message);\n    }\n\n    // ************************************** bool **************************************\n\n    /*\n        Function: isTrue\n        Assert that a boolean is 'true'.\n        : b == true\n        Params:\n            b (bool) - The boolean.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isTrue(bool b, string message) public returns (bool result) {\n        result = b;\n        _report(result, message);\n    }\n\n    /*\n        Function: isFalse\n        Assert that a boolean is 'false'.\n        : b == false\n        Params:\n            b (bool) - The boolean.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isFalse(bool b, string message) public returns (bool result) {\n        result = !b;\n        _report(result, message);\n    }\n\n    /*\n        Function: equal(bool)\n        Assert that two booleans are equal.\n        : A == B\n        Params:\n            A (bool) - The first boolean.\n            B (bool) - The second boolean.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(bool a, bool b, string message) public returns (bool result) {\n        result = (a == b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: notEqual(bool)\n        Assert that two booleans are not equal.\n        : A != B\n        Params:\n            A (bool) - The first boolean.\n            B (bool) - The second boolean.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(bool a, bool b, string message) public returns (bool result) {\n        result = (a != b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    // ************************************** uint **************************************\n\n    /*\n        Function: equal(uint)\n        Assert that two (256 bit) unsigned integers are equal.\n        : A == B\n        Params:\n            A (uint) - The first uint.\n            B (uint) - The second uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(uint a, uint b, string message) public returns (bool result) {\n        result = (a == b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: notEqual(uint)\n        Assert that two (256 bit) unsigned integers are not equal.\n        : A != B\n        Params:\n            A (uint) - The first uint.\n            B (uint) - The second uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(uint a, uint b, string message) public returns (bool result) {\n        result = (a != b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isAbove(uint)\n        Assert that the uint 'A' is greater than the uint 'B'.\n        : A > B\n        Params:\n            A (uint) - The first uint.\n            B (uint) - The second uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isAbove(uint a, uint b, string message) public returns (bool result) {\n        result = (a > b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isAtLeast(uint)\n        Assert that the uint 'A' is greater than or equal to the uint 'B'.\n        : A >= B\n        Params:\n            A (uint) - The first uint.\n            B (uint) - The second uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isAtLeast(uint a, uint b, string message) public returns (bool result) {\n        result = (a >= b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isBelow(uint)\n        Assert that the uint 'A' is lesser than the uint 'B'.\n        : A < B\n        Params:\n            A (uint) - The first uint.\n            B (uint) - The second uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isBelow(uint a, uint b, string message) public returns (bool result) {\n        result = (a < b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isAtMost(uint)\n        Assert that the uint 'A' is lesser than or equal to the uint 'B'.\n        : A <= B\n        Params:\n            A (uint) - The first uint.\n            B (uint) - The second uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isAtMost(uint a, uint b, string message) public returns (bool result) {\n        result = (a <= b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isZero(uint)\n        Assert that a (256 bit) unsigned integer is 0.\n        : number == 0\n        Params:\n            number (uint) - The uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isZero(uint number, string message) public returns (bool result) {\n        result = (number == 0);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(number, \"Tested\"), message));\n    }\n\n    /*\n        Function: isNotZero(uint)\n        Assert that a (256 bit) unsigned integer is not 0.\n        : number != 0\n        Params:\n            number (uint) - The uint.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isNotZero(uint number, string message) public returns (bool result) {\n        result = (number != 0);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(number, \"Tested\"), message));\n    }\n\n    // ************************************** int **************************************\n\n    /*\n        Function: equal(int)\n        Assert that two (256 bit) signed integers are equal.\n        : A == B\n        Params:\n            A (int) - The first int.\n            B (int) - The second int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(int a, int b, string message) public returns (bool result) {\n        result = (a == b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: notEqual(int)\n        Assert that two (256 bit) signed integers are not equal.\n        : A != B\n        Params:\n            A (int) - The first int.\n            B (int) - The second int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(int a, int b, string message) public returns (bool result) {\n        result = (a != b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isAbove(int)\n        Assert that the int 'A' is greater than the int 'B'.\n        : A > B\n        Params:\n            A (int) - The first int.\n            B (int) - The second int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isAbove(int a, int b, string message) public returns (bool result) {\n        result = (a > b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isAtLeast(int)\n        Assert that the int 'A' is greater than or equal to the int 'B'.\n        : A >= B\n        Params:\n            A (int) - The first int.\n            B (int) - The second int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isAtLeast(int a, int b, string message) public returns (bool result) {\n        result = (a >= b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isBelow(int)\n        Assert that the int 'A' is lesser than the int 'B'.\n        : A < B\n        Params:\n            A (int) - The first int.\n            B (int) - The second int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isBelow(int a, int b, string message) public returns (bool result) {\n        result = (a < b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isAtMost(int)\n        Assert that the int 'A' is lesser than or equal to the int 'B'.\n        : A <= B\n        Params:\n            A (int) - The first int.\n            B (int) - The second int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isAtMost(int a, int b, string message) public returns (bool result) {\n        result = (a <= b);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(a, \"Tested\"), _tag(b, \"Against\"), message));\n    }\n\n    /*\n        Function: isZero(int)\n        Assert that a (256 bit) signed integer is 0.\n        : number == 0\n        Params:\n            number (int) - The int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isZero(int number, string message) public returns (bool result) {\n        result = (number == 0);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(number, \"Tested\"), message));\n    }\n\n    /*\n        Function: isNotZero(int)\n        Assert that a (256 bit) signed integer is not 0.\n        : number != 0\n        Params:\n            number (int) - The int.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function isNotZero(int number, string message) public returns (bool result) {\n        result = (number != 0);\n        if (result)\n            _report(result, message);\n        else\n            _report(result, _appendTagged(_tag(number, \"Tested\"), message));\n    }\n\n    // ************************************** uint[] **************************************\n\n    /*\n        Function: equal(uint[])\n        Assert that two 'uint[ ]' are equal.\n        : arrA.length == arrB.length\n        and, for all valid indices 'i'\n        : arrA[i] == arrB[i]\n        Params:\n            A (uint[]) - The first array.\n            B (uint[]) - The second array.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(uint[] arrA, uint[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        _report(result, message);\n    }\n\n    /*\n        Function: notEqual(uint[])\n        Assert that two 'uint[]' are not equal.\n        : arrA.length != arrB.length\n        or, for some valid index 'i'\n        : arrA[i] != arrB[i]\n        Params:\n            A (uint[]) - The first string.\n            B (uint[]) - The second string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(uint[] arrA, uint[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        result = !result;\n        _report(result, message);\n    }\n\n    /*\n        Function: lengthEqual(uint[])\n        Assert that the length of a 'uint[]' is equal to a given value.\n        : arr.length == length\n        Params:\n            arr (uint[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthEqual(uint[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength == length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    /*\n        Function: lengthNotEqual(uint[])\n        Assert that the length of a 'uint[]' is not equal to a given value.\n        : arr.length != length\n        Params:\n            arr (uint[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthNotEqual(uint[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength != arr.length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    // ************************************** int[] **************************************\n\n    /*\n        Function: equal(int[])\n        Assert that two 'int[]' are equal.\n        : arrA.length == arrB.length\n        and, for all valid indices 'i'\n        : arrA[i] == arrB[i]\n        Params:\n            A (int[]) - The first array.\n            B (int[]) - The second array.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(int[] arrA, int[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        _report(result, message);\n    }\n\n    /*\n        Function: notEqual(int[])\n        Assert that two 'int[]' are not equal.\n        : arrA.length != arrB.length\n        or, for some valid index 'i'\n        : arrA[i] != arrB[i]\n        Params:\n            A (int[]) - The first string.\n            B (int[]) - The second string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(int[] arrA, int[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        result = !result;\n        _report(result, message);\n    }\n\n    /*\n        Function: lengthEqual(int[])\n        Assert that the length of an 'int[]' is equal to a given value.\n        : arr.length == length\n        Params:\n            arr (int[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthEqual(int[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength == length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    /*\n        Function: lengthNotEqual(int[])\n        Assert that the length of an 'int[]' is not equal to a given value.\n        : arr.length != length\n        Params:\n            arr (int[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthNotEqual(int[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength != arr.length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    // ************************************** address[] **************************************\n\n    /*\n        Function: equal(address[])\n        Assert that two 'address[]' are equal.\n        : arrA.length == arrB.length\n        and, for all valid indices 'i'\n        : arrA[i] == arrB[i]\n        Params:\n            A (address[]) - The first array.\n            B (address[]) - The second array.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(address[] arrA, address[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        _report(result, message);\n    }\n\n    /*\n        Function: notEqual(address[])\n        Assert that two 'address[]' are not equal.\n        : arrA.length != arrB.length\n        or, for some valid index 'i'\n        : arrA[i] != arrB[i]\n        Params:\n            A (address[]) - The first string.\n            B (address[]) - The second string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(address[] arrA, address[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        result = !result;\n        _report(result, message);\n    }\n\n    /*\n        Function: lengthEqual(address[])\n        Assert that the length of an 'address[]' is equal to a given value.\n        : arr.length == length\n        Params:\n            arr (address[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthEqual(address[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength == length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    /*\n        Function: lengthNotEqual(address[])\n        Assert that the length of an 'address[]' is not equal to a given value.\n        : arr.length != length\n        Params:\n            arr (address[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthNotEqual(address[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength != arr.length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    // ************************************** bytes32[] **************************************\n\n    /*\n        Function: equal(bytes32[])\n        Assert that two 'bytes32[]' are equal.\n        : arrA.length == arrB.length\n        and, for all valid indices 'i'\n        : arrA[i] == arrB[i]\n        Params:\n            A (bytes32[]) - The first array.\n            B (bytes32[]) - The second array.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function equal(bytes32[] arrA, bytes32[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        _report(result, message);\n    }\n\n    /*\n        Function: notEqual(bytes32[])\n        Assert that two 'bytes32[]' are not equal.\n        : arrA.length != arrB.length\n        or, for some valid index 'i'\n        : arrA[i] != arrB[i]\n        Params:\n            A (bytes32[]) - The first string.\n            B (bytes32[]) - The second string.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function notEqual(bytes32[] arrA, bytes32[] arrB, string message) public returns (bool result) {\n        result = arrA.length == arrB.length;\n        if (result) {\n            for (uint i = 0; i < arrA.length; i++) {\n                if (arrA[i] != arrB[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        result = !result;\n        _report(result, message);\n    }\n\n    /*\n        Function: lengthEqual(bytes32[])\n        Assert that the length of an 'bytes32[]' is equal to a given value.\n        : arr.length == length\n        Params:\n            arr (bytes32[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthEqual(bytes32[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength == length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    /*\n        Function: lengthNotEqual(bytes32[])\n        Assert that the length of an 'bytes32[]' is not equal to a given value.\n        : arr.length != length\n        Params:\n            arr (bytes32[]) - The array.\n            length (uint) - The length.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function lengthNotEqual(bytes32[] arr, uint length, string message) public returns (bool result) {\n        uint arrLength = arr.length;\n        if (arrLength != arr.length)\n            _report(result, \"\");\n        else\n            _report(result, _appendTagged(_tag(arrLength, \"Tested\"), _tag(length, \"Against\"), message));\n    }\n\n    // ************************************** balances **************************************\n\n    /*\n        Function: balanceEqual\n        Assert that the balance of an account 'A' is equal to a given number 'b'.\n        : A.balance = b\n        Params:\n            A (address) - The first address.\n            b (uint) - The balance.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function balanceEqual(address a, uint b, string message) public returns (bool result) {\n        result = (a.balance == b);\n        _report(result, message);\n    }\n\n    /*\n        Function: balanceNotEqual\n        Assert that the balance of an account 'A' is not equal to a given number 'b'.\n        : A.balance != b\n        Params:\n            A (address) - The first address.\n            b (uint) - The balance.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function balanceNotEqual(address a, uint b, string message) public returns (bool result) {\n        result = (a.balance != b);\n        _report(result, message);\n    }\n\n    /*\n        Function: balanceIsZero\n        Assert that the balance of an account 'A' is zero.\n        : A.balance == 0\n        Params:\n            A (address) - The first address.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function balanceIsZero(address a, string message) public returns (bool result) {\n        result = (a.balance == 0);\n        _report(result, message);\n    }\n\n    /*\n        Function: balanceIsNotZero\n        Assert that the balance of an account 'A' is not zero.\n        : A.balance != 0\n        Params:\n            A (address) - The first address.\n            message (string) - A message that is sent if the assertion fails.\n        Returns:\n            result (bool) - The result.\n    */\n    function balanceIsNotZero(address a, string message) public returns (bool result) {\n        result = (a.balance != 0);\n        _report(result, message);\n    }\n\n    /******************************** internal ********************************/\n\n        /*\n            Function: _report\n            Internal function for triggering <TestEvent>.\n            Params:\n                result (bool) - The test result (true or false).\n                message (string) - The message that is sent if the assertion fails.\n        */\n    function _report(bool result, string message) internal {\n        if(result)\n            emit TestEvent(true, \"\");\n        else\n            emit TestEvent(false, message);\n    }\n\n    /*\n        Function: _stringsEqual\n        Compares two strings. Taken from the StringUtils contract in the Ethereum Dapp-bin\n        (https://github.com/ethereum/dapp-bin/blob/master/library/stringUtils.sol).\n        Params:\n            a (string) - The first string.\n            b (string) - The second string.\n        Returns:\n             result (bool) - 'true' if the strings are equal, otherwise 'false'.\n    */\n    function _stringsEqual(string a, string b) internal pure returns (bool result) {\n        bytes memory ba = bytes(a);\n        bytes memory bb = bytes(b);\n\n        if (ba.length != bb.length)\n            return false;\n        for (uint i = 0; i < ba.length; i ++) {\n            if (ba[i] != bb[i])\n                return false;\n        }\n        return true;\n    }\n\n    /*\n        Function: _itoa\n        Convert a signed integer to a string. Negative numbers gets a '-' in front, e.g. \"-54\".\n        Params:\n            n (int) - The integer.\n            radix (uint8) - A number between 2 and 16 (inclusive). Characters used are 0-9,a-f\n        Returns:\n            result (string) - The resulting string.\n    */\n    function _itoa(int n, uint8 radix) internal pure returns (string) {\n        if (n == 0 || radix < 2 || radix > 16)\n            return '0';\n        bytes memory bts = new bytes(256);\n        uint i;\n        bool neg = false;\n        if (n < 0) {\n            n = -n;\n            neg = true;\n        }\n        while (n > 0) {\n            bts[i++] = _utoa(uint8(n % radix)); // Turn it to ascii.\n            n /= radix;\n        }\n        // Reverse\n        uint size = i;\n        uint j = 0;\n        bytes memory rev;\n        if (neg) {\n            size++;\n            j = 1;\n            rev = new bytes(size);\n            rev[0] = MINUS;\n        }\n        else\n            rev = new bytes(size);\n\n        for (; j < size; j++)\n            rev[j] = bts[size - j - 1];\n        return string(rev);\n    }\n\n    /*\n        Function: _utoa(uint)\n        Convert an  unsigned integer to a string.\n        Params:\n            n (uint) - The unsigned integer.\n            radix (uint8) - A number between 2 and 16 (inclusive). Characters used are 0-9,a-f\n        Returns:\n            result (string) - The resulting string.\n    */\n    function _utoa(uint n, uint8 radix) internal pure returns (string) {\n        if (n == 0 || radix < 2 || radix > 16)\n            return '0';\n        bytes memory bts = new bytes(256);\n        uint i;\n        while (n > 0) {\n            bts[i++] = _utoa(uint8(n % radix)); // Turn it to ascii.\n            n /= radix;\n        }\n        // Reverse\n        bytes memory rev = new bytes(i);\n        for (uint j = 0; j < i; j++)\n            rev[j] = bts[i - j - 1];\n        return string(rev);\n    }\n\n    /*\n        Function: _utoa(uint8)\n        Convert an unsigned 8-bit integer to its ASCII byte representation. Numbers 0-9 are converted to '0'-'9',\n        numbers 10-16 to 'a'-'f'. Numbers larger then 16 return the null byte.\n        Params:\n            u (uint8) - The unsigned 8-bit integer.\n        Returns:\n            result (string) - The ASCII byte.\n    */\n    function _utoa(uint8 u) internal pure returns (byte) {\n        if (u < 10)\n            return byte(u + ZERO);\n        else if (u < 16)\n            return byte(u - 10 + A);\n        else\n            return 0;\n    }\n\n    /*\n        Function: _ltoa\n        Convert an boolean to a string.\n        Params:\n            val (bool) - The boolean.\n        Returns:\n            result (string) - \"true\" if true, \"false\" if false.\n    */\n    function _ltoa(bool val) internal pure returns (string) {\n        bytes memory b;\n        if (val) {\n            b = new bytes(4);\n            b[0] = 't';\n            b[1] = 'r';\n            b[2] = 'u';\n            b[3] = 'e';\n            return string(b);\n        }\n        else {\n            b = new bytes(5);\n            b[0] = 'f';\n            b[1] = 'a';\n            b[2] = 'l';\n            b[3] = 's';\n            b[4] = 'e';\n            return string(b);\n        }\n    }\n\n    /*\n    function htoa(address addr) constant returns (string) {\n        bytes memory bts = new bytes(40);\n        bytes20 addrBts = bytes20(addr);\n        for (uint i = 0; i < 20; i++) {\n            bts[2*i] = addrBts[i] % 16;\n            bts[2*i + 1] = (addrBts[i] / 16) % 16;\n        }\n        return string(bts);\n    }\n    */\n\n    /*\n        Function: _tag(string)\n        Add a tag to a string. The 'value' and 'tag' strings are returned on the form \"tag: value\".\n        Params:\n            value (string) - The value.\n            tag (string) - The tag.\n        Returns:\n            result (string) - \"tag: value\"\n    */\n    function _tag(string value, string tag) internal pure returns (string) {\n\n        bytes memory valueB = bytes(value);\n        bytes memory tagB = bytes(tag);\n\n        uint vl = valueB.length;\n        uint tl = tagB.length;\n\n        bytes memory newB = new bytes(vl + tl + 2);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < tl; i++)\n            newB[j++] = tagB[i];\n        newB[j++] = ':';\n        newB[j++] = ' ';\n        for (i = 0; i < vl; i++)\n            newB[j++] = valueB[i];\n\n        return string(newB);\n    }\n\n    /*\n        Function: _tag(int)\n        Add a tag to an int.\n        Params:\n            value (int) - The value.\n            tag (string) - The tag.\n        Returns:\n            result (string) - \"tag: _itoa(value)\"\n    */\n    function _tag(int value, string tag) internal pure returns (string) {\n        string memory nstr = _itoa(value, 10);\n        return _tag(nstr, tag);\n    }\n\n    /*\n        Function: _tag(uint)\n        Add a tag to an uint.\n        Params:\n            value (uint) - The value.\n            tag (string) - The tag.\n        Returns:\n            result (string) - \"tag: _utoa(value)\"\n    */\n    function _tag(uint value, string tag) internal pure returns (string) {\n        string memory nstr = _utoa(value, 10);\n        return _tag(nstr, tag);\n    }\n\n    /*\n        Function: _tag(bool)\n        Add a tag to a boolean.\n        Params:\n            value (bool) - The value.\n            tag (string) - The tag.\n        Returns:\n            result (string) - \"tag: _ltoa(value)\"\n    */\n    function _tag(bool value, string tag) internal pure returns (string) {\n        string memory nstr = _ltoa(value);\n        return _tag(nstr, tag);\n    }\n\n    /*\n        Function: _appendTagged(string)\n        Append a tagged value to a string.\n        Params:\n            tagged (string) - The tagged value.\n            str (string) - The string.\n        Returns:\n            result (string) - \"str (tagged)\"\n    */\n    function _appendTagged(string tagged, string str) internal pure returns (string) {\n\n        bytes memory taggedB = bytes(tagged);\n        bytes memory strB = bytes(str);\n\n        uint sl = strB.length;\n        uint tl = taggedB.length;\n\n        bytes memory newB = new bytes(sl + tl + 3);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < sl; i++)\n            newB[j++] = strB[i];\n        newB[j++] = ' ';\n        newB[j++] = '(';\n        for (i = 0; i < tl; i++)\n            newB[j++] = taggedB[i];\n        newB[j++] = ')';\n\n        return string(newB);\n    }\n\n    /*\n        Function: _appendTagged(string, string)\n        Append two tagged values to a string.\n        Params:\n            tagged0 (string) - The first tagged value.\n            tagged1 (string) - The second tagged value.\n            str (string) - The string.\n        Returns:\n            result (string) - \"str (tagged0, tagged1)\"\n    */\n    function _appendTagged(string tagged0, string tagged1, string str) internal pure returns (string) {\n\n        bytes memory tagged0B = bytes(tagged0);\n        bytes memory tagged1B = bytes(tagged1);\n        bytes memory strB = bytes(str);\n\n        uint sl = strB.length;\n        uint t0l = tagged0B.length;\n        uint t1l = tagged1B.length;\n\n        bytes memory newB = new bytes(sl + t0l + t1l + 5);\n\n        uint i;\n        uint j;\n\n        for (i = 0; i < sl; i++)\n            newB[j++] = strB[i];\n        newB[j++] = ' ';\n        newB[j++] = '(';\n        for (i = 0; i < t0l; i++)\n            newB[j++] = tagged0B[i];\n        newB[j++] = ',';\n        newB[j++] = ' ';\n        for (i = 0; i < t1l; i++)\n            newB[j++] = tagged1B[i];\n        newB[j++] = ')';\n\n        return string(newB);\n    }\n\n}\n"
    },
    "contracts/test/helpers/ACLHelper.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../acl/IACLOracle.sol\";\n\n\ncontract ACLHelper {\n    function encodeOperator(uint256 param1, uint256 param2) internal pure returns (uint240) {\n        return encodeIfElse(param1, param2, 0);\n    }\n\n    function encodeIfElse(uint256 condition, uint256 successParam, uint256 failureParam) internal pure returns (uint240) {\n        return uint240(condition + (successParam << 32) + (failureParam << 64));\n    }\n}\n\n\ncontract AcceptOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {\n        return true;\n    }\n}\n\n\ncontract RejectOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {\n        return false;\n    }\n}\n\n\ncontract RevertOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {\n        revert();\n    }\n}\n\ncontract AssertOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {\n        assert(false);\n    }\n}\n\n// Can't implement from IACLOracle as its canPerform() is marked as view-only\ncontract StateModifyingOracle /* is IACLOracle */ {\n    bool modifyState;\n\n    function canPerform(address, address, bytes32, uint256[]) external returns (bool) {\n        modifyState = true;\n        return true;\n    }\n}\n\ncontract EmptyDataReturnOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {\n        assembly {\n            return(0, 0)\n        }\n    }\n}\n\ncontract ConditionalOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[] how) external view returns (bool) {\n        return how[0] > 0;\n    }\n}\n\ncontract OverGasLimitOracle is IACLOracle {\n    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {\n        while (true) {\n            // Do an SLOAD to increase the per-loop gas costs\n            uint256 loadFromStorage;\n            assembly { loadFromStorage := sload(0) }\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/test/tests/TestDelegateProxy.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../helpers/Assert.sol\";\nimport \"../helpers/ThrowProxy.sol\";\n\nimport \"../../common/DelegateProxy.sol\";\nimport \"../../evmscript/ScriptHelpers.sol\";\n\n\ncontract Target {\n    function dontReturn() public pure {}\n    function fail() public pure { revert(); }\n    function die() public { selfdestruct(0); }\n}\n\n\ncontract TestDelegateProxy is DelegateProxy {\n    using ScriptHelpers for *;\n\n    Target target;\n    ThrowProxy throwProxy;\n\n    // Mock ERCProxy implementation\n    function implementation() public view returns (address) {\n        return this;\n    }\n\n    function proxyType() public pure returns (uint256) {\n        return FORWARDING;\n    }\n\n    // Tests\n    function beforeAll() public {\n        target = new Target();\n    }\n\n    function beforeEach() public {\n        throwProxy = new ThrowProxy(address(this));\n    }\n\n    function testFailIfNoContract() public {\n        TestDelegateProxy(throwProxy).noContract();\n        throwProxy.assertThrows(\"should have reverted if target is not a contract\");\n    }\n\n    function noContract() public {\n        delegatedFwd(address(0x1234), target.dontReturn.selector.toBytes());\n    }\n\n    function testFailIfReverts() public {\n        TestDelegateProxy(throwProxy).revertCall();\n        throwProxy.assertThrows(\"should have reverted if call reverted\");\n    }\n\n    function revertCall() public {\n        delegatedFwd(target, target.fail.selector.toBytes());\n    }\n\n    function testIsContractZero() public {\n        bool result = isContract(address(0));\n        Assert.isFalse(result, \"should return false\");\n    }\n\n    function testIsContractAddress() public {\n        address nonContract = 0x1234;\n        bool result = isContract(nonContract);\n        Assert.isFalse(result, \"should return false\");\n    }\n\n    // keep as last test as it will kill this contract\n    function testDieIfMinReturn0() public {\n        Assert.isTrue(true, ''); // Make at least one assertion to satisfy the runner\n\n        delegatedFwd(target, target.die.selector.toBytes());\n        Assert.fail('should be dead');\n    }\n}\n"
    },
    "contracts/test/helpers/ThrowProxy.sol": {
      "content": "pragma solidity ^0.4.24;\n\nimport \"./Assert.sol\";\n\n// Based on Simon de la Rouviere method: http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests\n\n\n// Proxy contract for testing throws\ncontract ThrowProxy {\n  address public target;\n  bytes data;\n\n  constructor(address _target) public {\n    target = _target;\n  }\n\n  //prime the data using the fallback function.\n  function() public {\n    data = msg.data;\n  }\n\n  function assertThrows(string _msg) public {\n    Assert.isFalse(execute(), _msg);\n  }\n\n  function assertItDoesntThrow(string _msg) public {\n    Assert.isTrue(execute(), _msg);\n  }\n\n  function execute() public returns (bool) {\n    return target.call(data);\n  }\n}\n"
    },
    "contracts/common/DelegateProxy.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../common/IsContract.sol\";\nimport \"../lib/misc/ERCProxy.sol\";\n\n\ncontract DelegateProxy is ERCProxy, IsContract {\n    uint256 internal constant FWD_GAS_LIMIT = 10000;\n\n    /**\n    * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n    * @param _dst Destination address to perform the delegatecall\n    * @param _calldata Calldata for the delegatecall\n    */\n    function delegatedFwd(address _dst, bytes _calldata) internal {\n        require(isContract(_dst));\n        uint256 fwdGasLimit = FWD_GAS_LIMIT;\n\n        assembly {\n            let result := delegatecall(sub(gas, fwdGasLimit), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n            let size := returndatasize\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, size)\n\n            // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n            // if the call returned error data, forward it\n            switch result case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n"
    },
    "contracts/evmscript/ScriptHelpers.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\nlibrary ScriptHelpers {\n    function getSpecId(bytes _script) internal pure returns (uint32) {\n        return uint32At(_script, 0);\n    }\n\n    function uint256At(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := mload(add(_data, add(0x20, _location)))\n        }\n    }\n\n    function addressAt(bytes _data, uint256 _location) internal pure returns (address result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffffffffffffffffffffffffffffffffffff000000000000000000000000),\n            0x1000000000000000000000000)\n        }\n    }\n\n    function uint32At(bytes _data, uint256 _location) internal pure returns (uint32 result) {\n        uint256 word = uint256At(_data, _location);\n\n        assembly {\n            result := div(and(word, 0xffffffff00000000000000000000000000000000000000000000000000000000),\n            0x100000000000000000000000000000000000000000000000000000000)\n        }\n    }\n\n    function locationOf(bytes _data, uint256 _location) internal pure returns (uint256 result) {\n        assembly {\n            result := add(_data, add(0x20, _location))\n        }\n    }\n\n    function toBytes(bytes4 _sig) internal pure returns (bytes) {\n        bytes memory payload = new bytes(4);\n        assembly { mstore(add(payload, 0x20), _sig) }\n        return payload;\n    }\n}\n"
    },
    "contracts/lib/misc/ERCProxy.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ERCProxy {\n    uint256 internal constant FORWARDING = 1;\n    uint256 internal constant UPGRADEABLE = 2;\n\n    function proxyType() public pure returns (uint256 proxyTypeId);\n    function implementation() public view returns (address codeAddr);\n}\n"
    },
    "contracts/evmscript/executors/CallsScript.sol": {
      "content": "pragma solidity 0.4.24;\n\n// Inspired by https://github.com/reverendus/tx-manager\n\nimport \"../ScriptHelpers.sol\";\nimport \"./BaseEVMScriptExecutor.sol\";\n\n\ncontract CallsScript is BaseEVMScriptExecutor {\n    using ScriptHelpers for bytes;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant EXECUTOR_TYPE = keccak256(\"CALLS_SCRIPT\");\n    */\n    bytes32 internal constant EXECUTOR_TYPE = 0x2dc858a00f3e417be1394b87c07158e989ec681ce8cc68a9093680ac1a870302;\n\n    string private constant ERROR_BLACKLISTED_CALL = \"EVMCALLS_BLACKLISTED_CALL\";\n    string private constant ERROR_INVALID_LENGTH = \"EVMCALLS_INVALID_LENGTH\";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_CALL_REVERTED = \"EVMCALLS_CALL_REVERTED\";\n    */\n\n    event LogScriptCall(address indexed sender, address indexed src, address indexed dst);\n\n    /**\n    * @notice Executes a number of call scripts\n    * @param _script [ specId (uint32) ] many calls with this structure ->\n    *    [ to (address: 20 bytes) ] [ calldataLength (uint32: 4 bytes) ] [ calldata (calldataLength bytes) ]\n    * @param _blacklist Addresses the script cannot call to, or will revert.\n    * @return Always returns empty byte array\n    */\n    function execScript(bytes _script, bytes, address[] _blacklist) external isInitialized returns (bytes) {\n        uint256 location = SCRIPT_START_LOCATION; // first 32 bits are spec id\n        while (location < _script.length) {\n            // Check there's at least address + calldataLength available\n            require(_script.length - location >= 0x18, ERROR_INVALID_LENGTH);\n\n            address contractAddress = _script.addressAt(location);\n            // Check address being called is not blacklist\n            for (uint256 i = 0; i < _blacklist.length; i++) {\n                require(contractAddress != _blacklist[i], ERROR_BLACKLISTED_CALL);\n            }\n\n            // logged before execution to ensure event ordering in receipt\n            // if failed entire execution is reverted regardless\n            emit LogScriptCall(msg.sender, address(this), contractAddress);\n\n            uint256 calldataLength = uint256(_script.uint32At(location + 0x14));\n            uint256 startOffset = location + 0x14 + 0x04;\n            uint256 calldataStart = _script.locationOf(startOffset);\n\n            // compute end of script / next location\n            location = startOffset + calldataLength;\n            require(location <= _script.length, ERROR_INVALID_LENGTH);\n\n            bool success;\n            assembly {\n                success := call(\n                    sub(gas, 5000),       // forward gas left - 5000\n                    contractAddress,      // address\n                    0,                    // no value\n                    calldataStart,        // calldata start\n                    calldataLength,       // calldata length\n                    0,                    // don't write output\n                    0                     // don't write output\n                )\n\n                switch success\n                case 0 {\n                    let ptr := mload(0x40)\n\n                    switch returndatasize\n                    case 0 {\n                        // No error data was returned, revert with \"EVMCALLS_CALL_REVERTED\"\n                        // See remix: doing a `revert(\"EVMCALLS_CALL_REVERTED\")` always results in\n                        // this memory layout\n                        mstore(ptr, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                        mstore(add(ptr, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                        mstore(add(ptr, 0x24), 0x0000000000000000000000000000000000000000000000000000000000000016) // reason length\n                        mstore(add(ptr, 0x44), 0x45564d43414c4c535f43414c4c5f524556455254454400000000000000000000) // reason\n\n                        revert(ptr, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                    }\n                    default {\n                        // Forward the full error data\n                        returndatacopy(ptr, 0, returndatasize)\n                        revert(ptr, returndatasize)\n                    }\n                }\n                default { }\n            }\n        }\n        // No need to allocate empty bytes for the return as this can only be called via an delegatecall\n        // (due to the isInitialized modifier)\n    }\n\n    function executorType() external pure returns (bytes32) {\n        return EXECUTOR_TYPE;\n    }\n}\n"
    },
    "contracts/evmscript/executors/BaseEVMScriptExecutor.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../../common/Autopetrified.sol\";\nimport \"../IEVMScriptExecutor.sol\";\n\n\ncontract BaseEVMScriptExecutor is IEVMScriptExecutor, Autopetrified {\n    uint256 internal constant SCRIPT_START_LOCATION = 4;\n}\n"
    },
    "contracts/factory/EVMScriptRegistryFactory.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../evmscript/IEVMScriptExecutor.sol\";\nimport \"../evmscript/EVMScriptRegistry.sol\";\n\nimport \"../evmscript/executors/CallsScript.sol\";\n\nimport \"../kernel/Kernel.sol\";\nimport \"../acl/ACL.sol\";\n\n\ncontract EVMScriptRegistryFactory is EVMScriptRegistryConstants {\n    EVMScriptRegistry public baseReg;\n    IEVMScriptExecutor public baseCallScript;\n\n    /**\n    * @notice Create a new EVMScriptRegistryFactory.\n    */\n    constructor() public {\n        baseReg = new EVMScriptRegistry();\n        baseCallScript = IEVMScriptExecutor(new CallsScript());\n    }\n\n    /**\n    * @notice Install a new pinned instance of EVMScriptRegistry on `_dao`.\n    * @param _dao Kernel\n    * @return Installed EVMScriptRegistry\n    */\n    function newEVMScriptRegistry(Kernel _dao) public returns (EVMScriptRegistry reg) {\n        bytes memory initPayload = abi.encodeWithSelector(reg.initialize.selector);\n        reg = EVMScriptRegistry(_dao.newPinnedAppInstance(EVMSCRIPT_REGISTRY_APP_ID, baseReg, initPayload, true));\n\n        ACL acl = ACL(_dao.acl());\n\n        acl.createPermission(this, reg, reg.REGISTRY_ADD_EXECUTOR_ROLE(), this);\n\n        reg.addScriptExecutor(baseCallScript);     // spec 1 = CallsScript\n\n        // Clean up the permissions\n        acl.revokePermission(this, reg, reg.REGISTRY_ADD_EXECUTOR_ROLE());\n        acl.removePermissionManager(reg, reg.REGISTRY_ADD_EXECUTOR_ROLE());\n\n        return reg;\n    }\n}\n"
    },
    "contracts/evmscript/EVMScriptRegistry.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../apps/AragonApp.sol\";\nimport \"./ScriptHelpers.sol\";\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\n\n/* solium-disable function-order */\n// Allow public initialize() to be first\ncontract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, AragonApp {\n    using ScriptHelpers for bytes;\n\n    /* Hardcoded constants to save gas\n    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = keccak256(\"REGISTRY_ADD_EXECUTOR_ROLE\");\n    bytes32 public constant REGISTRY_MANAGER_ROLE = keccak256(\"REGISTRY_MANAGER_ROLE\");\n    */\n    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = 0xc4e90f38eea8c4212a009ca7b8947943ba4d4a58d19b683417f65291d1cd9ed2;\n    // WARN: Manager can censor all votes and the like happening in an org\n    bytes32 public constant REGISTRY_MANAGER_ROLE = 0xf7a450ef335e1892cb42c8ca72e7242359d7711924b75db5717410da3f614aa3;\n\n    uint256 internal constant SCRIPT_START_LOCATION = 4;\n\n    string private constant ERROR_INEXISTENT_EXECUTOR = \"EVMREG_INEXISTENT_EXECUTOR\";\n    string private constant ERROR_EXECUTOR_ENABLED = \"EVMREG_EXECUTOR_ENABLED\";\n    string private constant ERROR_EXECUTOR_DISABLED = \"EVMREG_EXECUTOR_DISABLED\";\n    string private constant ERROR_SCRIPT_LENGTH_TOO_SHORT = \"EVMREG_SCRIPT_LENGTH_TOO_SHORT\";\n\n    struct ExecutorEntry {\n        IEVMScriptExecutor executor;\n        bool enabled;\n    }\n\n    uint256 private executorsNextIndex;\n    mapping (uint256 => ExecutorEntry) public executors;\n\n    event EnableExecutor(uint256 indexed executorId, address indexed executorAddress);\n    event DisableExecutor(uint256 indexed executorId, address indexed executorAddress);\n\n    modifier executorExists(uint256 _executorId) {\n        require(_executorId > 0 && _executorId < executorsNextIndex, ERROR_INEXISTENT_EXECUTOR);\n        _;\n    }\n\n    /**\n    * @notice Initialize the registry\n    */\n    function initialize() public onlyInit {\n        initialized();\n        // Create empty record to begin executor IDs at 1\n        executorsNextIndex = 1;\n    }\n\n    /**\n    * @notice Add a new script executor with address `_executor` to the registry\n    * @param _executor Address of the IEVMScriptExecutor that will be added to the registry\n    * @return id Identifier of the executor in the registry\n    */\n    function addScriptExecutor(IEVMScriptExecutor _executor) external auth(REGISTRY_ADD_EXECUTOR_ROLE) returns (uint256 id) {\n        uint256 executorId = executorsNextIndex++;\n        executors[executorId] = ExecutorEntry(_executor, true);\n        emit EnableExecutor(executorId, _executor);\n        return executorId;\n    }\n\n    /**\n    * @notice Disable script executor with ID `_executorId`\n    * @param _executorId Identifier of the executor in the registry\n    */\n    function disableScriptExecutor(uint256 _executorId)\n        external\n        authP(REGISTRY_MANAGER_ROLE, arr(_executorId))\n    {\n        // Note that we don't need to check for an executor's existence in this case, as only\n        // existing executors can be enabled\n        ExecutorEntry storage executorEntry = executors[_executorId];\n        require(executorEntry.enabled, ERROR_EXECUTOR_DISABLED);\n        executorEntry.enabled = false;\n        emit DisableExecutor(_executorId, executorEntry.executor);\n    }\n\n    /**\n    * @notice Enable script executor with ID `_executorId`\n    * @param _executorId Identifier of the executor in the registry\n    */\n    function enableScriptExecutor(uint256 _executorId)\n        external\n        authP(REGISTRY_MANAGER_ROLE, arr(_executorId))\n        executorExists(_executorId)\n    {\n        ExecutorEntry storage executorEntry = executors[_executorId];\n        require(!executorEntry.enabled, ERROR_EXECUTOR_ENABLED);\n        executorEntry.enabled = true;\n        emit EnableExecutor(_executorId, executorEntry.executor);\n    }\n\n    /**\n    * @dev Get the script executor that can execute a particular script based on its first 4 bytes\n    * @param _script EVMScript being inspected\n    */\n    function getScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        require(_script.length >= SCRIPT_START_LOCATION, ERROR_SCRIPT_LENGTH_TOO_SHORT);\n        uint256 id = _script.getSpecId();\n\n        // Note that we don't need to check for an executor's existence in this case, as only\n        // existing executors can be enabled\n        ExecutorEntry storage entry = executors[id];\n        return entry.enabled ? entry.executor : IEVMScriptExecutor(0);\n    }\n}\n"
    },
    "contracts/kernel/Kernel.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"./IKernel.sol\";\nimport \"./KernelConstants.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../acl/IACL.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../common/ConversionHelpers.sol\";\nimport \"../common/IsContract.sol\";\nimport \"../common/Petrifiable.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../factory/AppProxyFactory.sol\";\nimport \"../lib/misc/ERCProxy.sol\";\n\n\n// solium-disable-next-line max-len\ncontract Kernel is IKernel, KernelStorage, KernelAppIds, KernelNamespaceConstants, Petrifiable, IsContract, VaultRecoverable, AppProxyFactory, ACLSyntaxSugar {\n    /* Hardcoded constants to save gas\n    bytes32 public constant APP_MANAGER_ROLE = keccak256(\"APP_MANAGER_ROLE\");\n    */\n    bytes32 public constant APP_MANAGER_ROLE = 0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0;\n\n    string private constant ERROR_APP_NOT_CONTRACT = \"KERNEL_APP_NOT_CONTRACT\";\n    string private constant ERROR_INVALID_APP_CHANGE = \"KERNEL_INVALID_APP_CHANGE\";\n    string private constant ERROR_AUTH_FAILED = \"KERNEL_AUTH_FAILED\";\n\n    /**\n    * @dev Constructor that allows the deployer to choose if the base instance should be petrified immediately.\n    * @param _shouldPetrify Immediately petrify this instance so that it can never be initialized\n    */\n    constructor(bool _shouldPetrify) public {\n        if (_shouldPetrify) {\n            petrify();\n        }\n    }\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initialize this kernel instance along with its ACL and set `_permissionsCreator` as the entity that can create other permissions\n    * @param _baseAcl Address of base ACL app\n    * @param _permissionsCreator Entity that will be given permission over createPermission\n    */\n    function initialize(IACL _baseAcl, address _permissionsCreator) public onlyInit {\n        initialized();\n\n        // Set ACL base\n        _setApp(KERNEL_APP_BASES_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, _baseAcl);\n\n        // Create ACL instance and attach it as the default ACL app\n        IACL acl = IACL(newAppProxy(this, KERNEL_DEFAULT_ACL_APP_ID));\n        acl.initialize(_permissionsCreator);\n        _setApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, acl);\n\n        recoveryVaultAppId = KERNEL_DEFAULT_VAULT_APP_ID;\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel\n    * @notice Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`\n    * @param _appId Identifier for app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _appId, address _appBase)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n        returns (ERCProxy appProxy)\n    {\n        return newAppInstance(_appId, _appBase, new bytes(0), false);\n    }\n\n    /**\n    * @dev Create a new instance of an app linked to this kernel and set its base\n    *      implementation if it was not already set\n    * @notice Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? 'Also sets it as the default app instance.':''`\n    * @param _appId Identifier for app\n    * @param _appBase Address of the app's base implementation\n    * @param _initializePayload Payload for call made by the proxy during its construction to initialize\n    * @param _setDefault Whether the app proxy app is the default one.\n    *        Useful when the Kernel needs to know of an instance of a particular app,\n    *        like Vault for escape hatch mechanism.\n    * @return AppProxy instance\n    */\n    function newAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n        returns (ERCProxy appProxy)\n    {\n        _setAppIfNew(KERNEL_APP_BASES_NAMESPACE, _appId, _appBase);\n        appProxy = newAppProxy(this, _appId, _initializePayload);\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\n        // and it will only succeed if sender has permissions to set something to the namespace.\n        if (_setDefault) {\n            setApp(KERNEL_APP_ADDR_NAMESPACE, _appId, appProxy);\n        }\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel\n    * @notice Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`.\n    * @param _appId Identifier for app\n    * @param _appBase Address of the app's base implementation\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _appId, address _appBase)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n        returns (ERCProxy appProxy)\n    {\n        return newPinnedAppInstance(_appId, _appBase, new bytes(0), false);\n    }\n\n    /**\n    * @dev Create a new pinned instance of an app linked to this kernel and set\n    *      its base implementation if it was not already set\n    * @notice Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? 'Also sets it as the default app instance.':''`\n    * @param _appId Identifier for app\n    * @param _appBase Address of the app's base implementation\n    * @param _initializePayload Payload for call made by the proxy during its construction to initialize\n    * @param _setDefault Whether the app proxy app is the default one.\n    *        Useful when the Kernel needs to know of an instance of a particular app,\n    *        like Vault for escape hatch mechanism.\n    * @return AppProxy instance\n    */\n    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n        returns (ERCProxy appProxy)\n    {\n        _setAppIfNew(KERNEL_APP_BASES_NAMESPACE, _appId, _appBase);\n        appProxy = newAppProxyPinned(this, _appId, _initializePayload);\n        // By calling setApp directly and not the internal functions, we make sure the params are checked\n        // and it will only succeed if sender has permissions to set something to the namespace.\n        if (_setDefault) {\n            setApp(KERNEL_APP_ADDR_NAMESPACE, _appId, appProxy);\n        }\n    }\n\n    /**\n    * @dev Set the resolving address of an app instance or base implementation\n    * @notice Set the resolving address of `_appId` in namespace `_namespace` to `_app`\n    * @param _namespace App namespace to use\n    * @param _appId Identifier for app\n    * @param _app Address of the app instance or base implementation\n    * @return ID of app\n    */\n    function setApp(bytes32 _namespace, bytes32 _appId, address _app)\n        public\n        auth(APP_MANAGER_ROLE, arr(_namespace, _appId))\n    {\n        _setApp(_namespace, _appId, _app);\n    }\n\n    /**\n    * @dev Set the default vault id for the escape hatch mechanism\n    * @param _recoveryVaultAppId Identifier of the recovery vault app\n    */\n    function setRecoveryVaultAppId(bytes32 _recoveryVaultAppId)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_ADDR_NAMESPACE, _recoveryVaultAppId))\n    {\n        recoveryVaultAppId = _recoveryVaultAppId;\n    }\n\n    // External access to default app id and namespace constants to mimic default getters for constants\n    /* solium-disable function-order, mixedcase */\n    function CORE_NAMESPACE() external pure returns (bytes32) { return KERNEL_CORE_NAMESPACE; }\n    function APP_BASES_NAMESPACE() external pure returns (bytes32) { return KERNEL_APP_BASES_NAMESPACE; }\n    function APP_ADDR_NAMESPACE() external pure returns (bytes32) { return KERNEL_APP_ADDR_NAMESPACE; }\n    function KERNEL_APP_ID() external pure returns (bytes32) { return KERNEL_CORE_APP_ID; }\n    function DEFAULT_ACL_APP_ID() external pure returns (bytes32) { return KERNEL_DEFAULT_ACL_APP_ID; }\n    /* solium-enable function-order, mixedcase */\n\n    /**\n    * @dev Get the address of an app instance or base implementation\n    * @param _namespace App namespace to use\n    * @param _appId Identifier for app\n    * @return Address of the app\n    */\n    function getApp(bytes32 _namespace, bytes32 _appId) public view returns (address) {\n        return apps[_namespace][_appId];\n    }\n\n    /**\n    * @dev Get the address of the recovery Vault instance (to recover funds)\n    * @return Address of the Vault\n    */\n    function getRecoveryVault() public view returns (address) {\n        return apps[KERNEL_APP_ADDR_NAMESPACE][recoveryVaultAppId];\n    }\n\n    /**\n    * @dev Get the installed ACL app\n    * @return ACL app\n    */\n    function acl() public view returns (IACL) {\n        return IACL(getApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID));\n    }\n\n    /**\n    * @dev Function called by apps to check ACL on kernel or to check permission status\n    * @param _who Sender of the original call\n    * @param _where Address of the app\n    * @param _what Identifier for a group of actions in app\n    * @param _how Extra data for ACL auth\n    * @return Boolean indicating whether the ACL allows the role or not.\n    *         Always returns false if the kernel hasn't been initialized yet.\n    */\n    function hasPermission(address _who, address _where, bytes32 _what, bytes _how) public view returns (bool) {\n        IACL defaultAcl = acl();\n        return address(defaultAcl) != address(0) && // Poor man's initialization check (saves gas)\n            defaultAcl.hasPermission(_who, _where, _what, _how);\n    }\n\n    function _setApp(bytes32 _namespace, bytes32 _appId, address _app) internal {\n        require(isContract(_app), ERROR_APP_NOT_CONTRACT);\n        apps[_namespace][_appId] = _app;\n        emit SetApp(_namespace, _appId, _app);\n    }\n\n    function _setAppIfNew(bytes32 _namespace, bytes32 _appId, address _app) internal {\n        address app = getApp(_namespace, _appId);\n        if (app != address(0)) {\n            // The only way to set an app is if it passes the isContract check, so no need to check it again\n            require(app == _app, ERROR_INVALID_APP_CHANGE);\n        } else {\n            _setApp(_namespace, _appId, _app);\n        }\n    }\n\n    modifier auth(bytes32 _role, uint256[] memory _params) {\n        require(\n            hasPermission(msg.sender, address(this), _role, ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)),\n            ERROR_AUTH_FAILED\n        );\n        _;\n    }\n}\n"
    },
    "contracts/kernel/KernelStorage.sol": {
      "content": "pragma solidity 0.4.24;\n\n\ncontract KernelStorage {\n    // namespace => app id => address\n    mapping (bytes32 => mapping (bytes32 => address)) public apps;\n    bytes32 public recoveryVaultAppId;\n}\n"
    },
    "contracts/factory/AppProxyFactory.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../apps/AppProxyUpgradeable.sol\";\nimport \"../apps/AppProxyPinned.sol\";\n\n\ncontract AppProxyFactory {\n    event NewAppProxy(address proxy, bool isUpgradeable, bytes32 appId);\n\n    /**\n    * @notice Create a new upgradeable app instance on `_kernel` with identifier `_appId`\n    * @param _kernel App's Kernel reference\n    * @param _appId Identifier for app\n    * @return AppProxyUpgradeable\n    */\n    function newAppProxy(IKernel _kernel, bytes32 _appId) public returns (AppProxyUpgradeable) {\n        return newAppProxy(_kernel, _appId, new bytes(0));\n    }\n\n    /**\n    * @notice Create a new upgradeable app instance on `_kernel` with identifier `_appId` and initialization payload `_initializePayload`\n    * @param _kernel App's Kernel reference\n    * @param _appId Identifier for app\n    * @return AppProxyUpgradeable\n    */\n    function newAppProxy(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyUpgradeable) {\n        AppProxyUpgradeable proxy = new AppProxyUpgradeable(_kernel, _appId, _initializePayload);\n        emit NewAppProxy(address(proxy), true, _appId);\n        return proxy;\n    }\n\n    /**\n    * @notice Create a new pinned app instance on `_kernel` with identifier `_appId`\n    * @param _kernel App's Kernel reference\n    * @param _appId Identifier for app\n    * @return AppProxyPinned\n    */\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId) public returns (AppProxyPinned) {\n        return newAppProxyPinned(_kernel, _appId, new bytes(0));\n    }\n\n    /**\n    * @notice Create a new pinned app instance on `_kernel` with identifier `_appId` and initialization payload `_initializePayload`\n    * @param _kernel App's Kernel reference\n    * @param _appId Identifier for app\n    * @param _initializePayload Proxy initialization payload\n    * @return AppProxyPinned\n    */\n    function newAppProxyPinned(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public returns (AppProxyPinned) {\n        AppProxyPinned proxy = new AppProxyPinned(_kernel, _appId, _initializePayload);\n        emit NewAppProxy(address(proxy), false, _appId);\n        return proxy;\n    }\n}\n"
    },
    "contracts/apps/AppProxyUpgradeable.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyUpgradeable is AppProxyBase {\n    /**\n    * @dev Initialize AppProxyUpgradeable (makes it an upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n        AppProxyBase(_kernel, _appId, _initializePayload)\n        public // solium-disable-line visibility-first\n    {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev ERC897, the address the proxy would delegate calls to\n     */\n    function implementation() public view returns (address) {\n        return getAppBase(appId());\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return UPGRADEABLE;\n    }\n}\n"
    },
    "contracts/apps/AppProxyPinned.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\nimport \"../common/IsContract.sol\";\nimport \"./AppProxyBase.sol\";\n\n\ncontract AppProxyPinned is IsContract, AppProxyBase {\n    using UnstructuredStorage for bytes32;\n\n    // keccak256(\"aragonOS.appStorage.pinnedCode\")\n    bytes32 internal constant PINNED_CODE_POSITION = 0xdee64df20d65e53d7f51cb6ab6d921a0a6a638a91e942e1d8d02df28e31c038e;\n\n    /**\n    * @dev Initialize AppProxyPinned (makes it an un-upgradeable Aragon app)\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload)\n        AppProxyBase(_kernel, _appId, _initializePayload)\n        public // solium-disable-line visibility-first\n    {\n        setPinnedCode(getAppBase(_appId));\n        require(isContract(pinnedCode()));\n    }\n\n    /**\n     * @dev ERC897, the address the proxy would delegate calls to\n     */\n    function implementation() public view returns (address) {\n        return pinnedCode();\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return FORWARDING;\n    }\n\n    function setPinnedCode(address _pinnedCode) internal {\n        PINNED_CODE_POSITION.setStorageAddress(_pinnedCode);\n    }\n\n    function pinnedCode() internal view returns (address) {\n        return PINNED_CODE_POSITION.getStorageAddress();\n    }\n}\n"
    },
    "contracts/apps/AppProxyBase.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"./AppStorage.sol\";\nimport \"../common/DepositableDelegateProxy.sol\";\nimport \"../kernel/KernelConstants.sol\";\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppProxyBase is AppStorage, DepositableDelegateProxy, KernelNamespaceConstants {\n    /**\n    * @dev Initialize AppProxy\n    * @param _kernel Reference to organization kernel for the app\n    * @param _appId Identifier for app\n    * @param _initializePayload Payload for call to be made after setup to initialize\n    */\n    constructor(IKernel _kernel, bytes32 _appId, bytes _initializePayload) public {\n        setKernel(_kernel);\n        setAppId(_appId);\n\n        // Implicit check that kernel is actually a Kernel\n        // The EVM doesn't actually provide a way for us to make sure, but we can force a revert to\n        // occur if the kernel is set to 0x0 or a non-code address when we try to call a method on\n        // it.\n        address appCode = getAppBase(_appId);\n\n        // If initialize payload is provided, it will be executed\n        if (_initializePayload.length > 0) {\n            require(isContract(appCode));\n            // Cannot make delegatecall as a delegateproxy.delegatedFwd as it\n            // returns ending execution context and halts contract deployment\n            require(appCode.delegatecall(_initializePayload));\n        }\n    }\n\n    function getAppBase(bytes32 _appId) internal view returns (address) {\n        return kernel().getApp(KERNEL_APP_BASES_NAMESPACE, _appId);\n    }\n}\n"
    },
    "contracts/common/DepositableDelegateProxy.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"./DelegateProxy.sol\";\nimport \"./DepositableStorage.sol\";\n\n\ncontract DepositableDelegateProxy is DepositableStorage, DelegateProxy {\n    event ProxyDeposit(address sender, uint256 value);\n\n    function () external payable {\n        uint256 forwardGasThreshold = FWD_GAS_LIMIT;\n        bytes32 isDepositablePosition = DEPOSITABLE_POSITION;\n\n        // Optimized assembly implementation to prevent EIP-1884 from breaking deposits, reference code in Solidity:\n        // https://github.com/aragon/aragonOS/blob/v4.2.1/contracts/common/DepositableDelegateProxy.sol#L10-L20\n        assembly {\n            // Continue only if the gas left is lower than the threshold for forwarding to the implementation code,\n            // otherwise continue outside of the assembly block.\n            if lt(gas, forwardGasThreshold) {\n                // Only accept the deposit and emit an event if all of the following are true:\n                // the proxy accepts deposits (isDepositable), msg.data.length == 0, and msg.value > 0\n                if and(and(sload(isDepositablePosition), iszero(calldatasize)), gt(callvalue, 0)) {\n                    // Equivalent Solidity code for emitting the event:\n                    // emit ProxyDeposit(msg.sender, msg.value);\n\n                    let logData := mload(0x40) // free memory pointer\n                    mstore(logData, caller) // add 'msg.sender' to the log data (first event param)\n                    mstore(add(logData, 0x20), callvalue) // add 'msg.value' to the log data (second event param)\n\n                    // Emit an event with one topic to identify the event: keccak256('ProxyDeposit(address,uint256)') = 0x15ee...dee1\n                    log1(logData, 0x40, 0x15eeaa57c7bd188c1388020bcadc2c436ec60d647d36ef5b9eb3c742217ddee1)\n\n                    stop() // Stop. Exits execution context\n                }\n\n                // If any of above checks failed, revert the execution (if ETH was sent, it is returned to the sender)\n                revert(0, 0)\n            }\n        }\n\n        address target = implementation();\n        delegatedFwd(target, msg.data);\n    }\n}\n"
    },
    "contracts/common/DepositableStorage.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"./UnstructuredStorage.sol\";\n\n\ncontract DepositableStorage {\n    using UnstructuredStorage for bytes32;\n\n    // keccak256(\"aragonOS.depositableStorage.depositable\")\n    bytes32 internal constant DEPOSITABLE_POSITION = 0x665fd576fbbe6f247aff98f5c94a561e3f71ec2d3c988d56f12d342396c50cea;\n\n    function isDepositable() public view returns (bool) {\n        return DEPOSITABLE_POSITION.getStorageBool();\n    }\n\n    function setDepositable(bool _depositable) internal {\n        DEPOSITABLE_POSITION.setStorageBool(_depositable);\n    }\n}\n"
    },
    "contracts/test/mocks/kernel/UpgradedKernel.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../kernel/Kernel.sol\";\n\n\ncontract UpgradedKernel is Kernel {\n    constructor(bool _shouldPetrify) Kernel(_shouldPetrify) public {}\n\n    // just adds one more function to the kernel implementation.\n    // calling this function on the previous instance will fail\n    function isUpgraded() public pure returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/mocks/kernel/KernelSetAppMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../kernel/Kernel.sol\";\n\ncontract KernelSetAppMock is Kernel {\n    constructor() Kernel(false) public {\n    }\n\n    // Overloaded mock to bypass the auth and isContract checks\n    function setApp(bytes32 _namespace, bytes32 _appId, address _app) public {\n        apps[_namespace][_appId] = _app;\n    }\n}\n"
    },
    "contracts/test/mocks/kernel/KernelOverloadMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../kernel/Kernel.sol\";\nimport \"../../../lib/misc/ERCProxy.sol\";\n\n\n/** Ugly hack to work around this issue:\n * https://github.com/trufflesuite/truffle/issues/569\n * https://github.com/trufflesuite/truffle/issues/737\n *\n * NOTE: awkwardly, by default we have access to the full version of `newAppInstance()` but only the\n * minimized version for `newPinnedAppInstance()`\n */\ncontract KernelOverloadMock {\n    Kernel public kernel;\n\n    event NewAppProxy(address proxy);\n\n    constructor(Kernel _kernel) public {\n        kernel = _kernel;\n    }\n\n    /*\n    function newAppInstance(bytes32 _appId, address _appBase)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n        returns (ERCProxy appProxy)\n    */\n    function newAppInstance(bytes32 _appId, address _appBase)\n        public\n        returns (ERCProxy appProxy)\n    {\n        appProxy = kernel.newAppInstance(_appId, _appBase);\n        emit NewAppProxy(appProxy);\n    }\n\n    /*\n    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\n        public\n        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))\n        returns (ERCProxy appProxy)\n    */\n    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)\n        public\n        returns (ERCProxy appProxy)\n    {\n        appProxy = kernel.newPinnedAppInstance(_appId, _appBase, _initializePayload, _setDefault);\n        emit NewAppProxy(appProxy);\n    }\n}\n"
    },
    "contracts/test/mocks/lib/misc/ERCProxyMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../../lib/misc/ERCProxy.sol\";\n\n\ncontract ERCProxyMock is ERCProxy {\n    uint256 public constant FORWARDING = 1;\n    uint256 public constant UPGRADEABLE = 2;\n\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return 0;\n    }\n\n    function implementation() public view returns (address codeAddr) {\n        return address(0);\n    }\n}\n"
    },
    "contracts/kernel/KernelProxy.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"./IKernel.sol\";\nimport \"./KernelConstants.sol\";\nimport \"./KernelStorage.sol\";\nimport \"../common/DepositableDelegateProxy.sol\";\nimport \"../common/IsContract.sol\";\n\n\ncontract KernelProxy is IKernelEvents, KernelStorage, KernelAppIds, KernelNamespaceConstants, IsContract, DepositableDelegateProxy {\n    /**\n    * @dev KernelProxy is a proxy contract to a kernel implementation. The implementation\n    *      can update the reference, which effectively upgrades the contract\n    * @param _kernelImpl Address of the contract used as implementation for kernel\n    */\n    constructor(IKernel _kernelImpl) public {\n        require(isContract(address(_kernelImpl)));\n        apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID] = _kernelImpl;\n\n        // Note that emitting this event is important for verifying that a KernelProxy instance\n        // was never upgraded to a malicious Kernel logic contract over its lifespan.\n        // This starts the \"chain of trust\", that can be followed through later SetApp() events\n        // emitted during kernel upgrades.\n        emit SetApp(KERNEL_CORE_NAMESPACE, KERNEL_CORE_APP_ID, _kernelImpl);\n    }\n\n    /**\n     * @dev ERC897, whether it is a forwarding (1) or an upgradeable (2) proxy\n     */\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return UPGRADEABLE;\n    }\n\n    /**\n    * @dev ERC897, the address the proxy would delegate calls to\n    */\n    function implementation() public view returns (address) {\n        return apps[KERNEL_CORE_NAMESPACE][KERNEL_CORE_APP_ID];\n    }\n}\n"
    },
    "contracts/test/mocks/apps/DepositableDelegateProxyMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/DepositableDelegateProxy.sol\";\n\n\ncontract DepositableDelegateProxyMock is DepositableDelegateProxy {\n    address private implementationMock;\n\n    function enableDepositsOnMock() external {\n        setDepositable(true);\n    }\n\n    function setImplementationOnMock(address _implementationMock) external {\n        implementationMock = _implementationMock;\n    }\n\n    function implementation() public view returns (address) {\n        return implementationMock;\n    }\n\n    function proxyType() public pure returns (uint256 proxyTypeId) {\n        return UPGRADEABLE;\n    }\n}\n"
    },
    "contracts/test/mocks/kernel/KernelDepositableMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/DepositableStorage.sol\";\nimport \"../../../kernel/Kernel.sol\";\n\ncontract KernelDepositableMock is Kernel, DepositableStorage {\n    constructor(bool _shouldPetrify) Kernel(_shouldPetrify) public {\n    }\n\n    function () external payable {\n        require(isDepositable());\n    }\n\n    function enableDeposits() external isInitialized {\n        setDepositable(true);\n    }\n}\n"
    },
    "contracts/test/mocks/common/DepositableStorageMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/DepositableStorage.sol\";\n\n\ncontract DepositableStorageMock is DepositableStorage {\n    function setDepositableExt(bool _depositable) public {\n        setDepositable(_depositable);\n    }\n\n    function getDepositablePosition() public pure returns (bytes32) {\n        return DEPOSITABLE_POSITION;\n    }\n}\n"
    },
    "contracts/test/mocks/apps/VaultMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/UnsafeAragonApp.sol\";\nimport \"../../../common/DepositableStorage.sol\";\n\n\ncontract VaultMock is UnsafeAragonApp, DepositableStorage {\n    event LogFund(address sender, uint256 amount);\n\n    function initialize() external {\n        initialized();\n        setDepositable(true);\n    }\n\n    function () external payable {\n        emit LogFund(msg.sender, msg.value);\n    }\n}\n"
    },
    "contracts/apps/UnsafeAragonApp.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\nimport \"./AragonApp.sol\";\n\n\n// Using UnsafeAragonApp means you'll be playing with 🔥.\n// A number of safe defaults are provided with AragonApp, to help you avoid dangerous situations\n// and mistakes with how your contract's developed as well as how it's deployed.\n// UnsafeAragonApp turns off these safety features to give you greater control over your contract.\n// In particular, it allows you to:\n//   - Use deployed base contracts as apps directly, without a proxy\ncontract UnsafeAragonApp is AragonApp {\n    using UnstructuredStorage for bytes32;\n\n    constructor() public {\n        // Removes auto petrifying; simulates a delete at INITIALIZATION_BLOCK_POSITION\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(0);\n    }\n}\n"
    },
    "contracts/test/mocks/apps/UnsafeAragonAppMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/UnsafeAragonApp.sol\";\nimport \"../../../kernel/IKernel.sol\";\n\n\ncontract UnsafeAragonAppMock is UnsafeAragonApp {\n    function initialize() public {\n        initialized();\n    }\n\n    function getKernel() public view returns (IKernel) {\n        return kernel();\n    }\n\n    function setKernelOnMock(IKernel _kernel) public {\n        setKernel(_kernel);\n    }\n}\n"
    },
    "contracts/test/mocks/apps/AppStub.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/AragonApp.sol\";\nimport \"../../../apps/UnsafeAragonApp.sol\";\nimport \"../../../kernel/IKernel.sol\";\n\n\ncontract AppStubStorage {\n    uint a;\n    string public stringTest;\n}\n\ncontract AppStub is AragonApp, AppStubStorage {\n    bytes32 public constant ROLE = keccak256(\"ROLE\");\n\n    function initialize() onlyInit public {\n        initialized();\n        stringTest = \"hola\";\n    }\n\n    function requiresInitialization() isInitialized public constant returns (bool) {\n        return true;\n    }\n\n    function setValue(uint i) auth(ROLE) public {\n        a = i;\n    }\n\n    function setValueParam(uint i) authP(ROLE, arr(i)) public {\n        a = i;\n    }\n\n    function getValue() public constant returns (uint) {\n        return a;\n    }\n}\n\ncontract AppStub2 is AragonApp, AppStubStorage {\n    function getValue() public constant returns (uint) {\n        return a * 2;\n    }\n}\n\ncontract UnsafeAppStub is AppStub, UnsafeAragonApp {\n    constructor(IKernel _kernel) public {\n        setKernel(_kernel);\n    }\n}\n"
    },
    "contracts/test/mocks/apps/AppStubScriptRunner.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/AragonApp.sol\";\n\n\ncontract AppStubScriptRunner is AragonApp {\n    event ReturnedBytes(bytes returnedBytes);\n\n    // Initialization is required to access any of the real executors\n    function initialize() public {\n        initialized();\n    }\n\n    function runScript(bytes script) public returns (bytes) {\n        bytes memory returnedBytes = runScript(script, new bytes(0), new address[](0));\n        emit ReturnedBytes(returnedBytes);\n        return returnedBytes;\n    }\n\n    function runScriptWithBan(bytes script, address[] memory blacklist) public returns (bytes) {\n        bytes memory returnedBytes = runScript(script, new bytes(0), blacklist);\n        emit ReturnedBytes(returnedBytes);\n        return returnedBytes;\n    }\n\n    function runScriptWithIO(bytes script, bytes input, address[] memory blacklist) public returns (bytes) {\n        bytes memory returnedBytes = runScript(script, input, blacklist);\n        emit ReturnedBytes(returnedBytes);\n        return returnedBytes;\n    }\n\n    function runScriptWithNewBytesAllocation(bytes script) public returns (bytes) {\n        bytes memory returnedBytes = runScript(script, new bytes(0), new address[](0));\n        bytes memory newBytes = new bytes(64);\n\n        // Fill in new bytes array with some dummy data to let us check it doesn't corrupt the\n        // script's returned bytes\n        uint256 first = uint256(keccak256(\"test\"));\n        uint256 second = uint256(keccak256(\"mock\"));\n        assembly {\n            mstore(add(newBytes, 0x20), first)\n            mstore(add(newBytes, 0x40), second)\n        }\n        emit ReturnedBytes(returnedBytes);\n        return returnedBytes;\n    }\n\n    /*\n    function getActionsCount(bytes script) public constant returns (uint256) {\n        return getScriptActionsCount(script);\n    }\n\n    function getAction(bytes script, uint256 i) public constant returns (address, bytes) {\n        return getScriptAction(script, i);\n    }\n    */\n}\n"
    },
    "contracts/test/mocks/apps/AppStubDepositable.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/AragonApp.sol\";\nimport \"../../../apps/UnsafeAragonApp.sol\";\nimport \"../../../common/DepositableStorage.sol\";\n\n\ncontract AppStubDepositable is AragonApp, DepositableStorage {\n    function () external payable {\n        require(isDepositable());\n    }\n\n    function initialize() onlyInit public {\n        initialized();\n    }\n\n    function enableDeposits() external {\n        setDepositable(true);\n    }\n}\n\ncontract UnsafeAppStubDepositable is AppStubDepositable, UnsafeAragonApp {\n    constructor(IKernel _kernel) public {\n        setKernel(_kernel);\n    }\n}\n"
    },
    "contracts/test/mocks/apps/AppStubConditionalRecovery.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/AragonApp.sol\";\nimport \"../../../common/DepositableStorage.sol\";\n\n\ncontract AppStubConditionalRecovery is AragonApp, DepositableStorage {\n    function initialize() onlyInit public {\n        initialized();\n        setDepositable(true);\n    }\n\n    function allowRecoverability(address token) public view returns (bool) {\n        // Doesn't allow to recover ether\n        return token != address(0);\n    }\n}\n"
    },
    "contracts/test/mocks/evmscript/EVMScriptRegistryConstantsMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../evmscript/IEVMScriptRegistry.sol\";\n\n\ncontract EVMScriptRegistryConstantsMock is EVMScriptRegistryConstants {\n    function getEVMScriptRegistryAppId() external pure returns (bytes32) { return EVMSCRIPT_REGISTRY_APP_ID; }\n}\n"
    },
    "contracts/test/mocks/evmscript/EVMScriptExecutorRevertMock.sol": {
      "content": "pragma solidity 0.4.24;\n\n\nimport \"../../../evmscript/executors/BaseEVMScriptExecutor.sol\";\n\ncontract EVMScriptExecutorRevertMock is BaseEVMScriptExecutor {\n    string public constant ERROR_MOCK_REVERT = \"MOCK_REVERT\";\n    bytes32 internal constant EXECUTOR_TYPE = keccak256(\"MOCK_REVERT_SCRIPT\");\n\n    function execScript(bytes, bytes, address[]) external isInitialized returns (bytes) {\n        revert(ERROR_MOCK_REVERT);\n    }\n\n    function executorType() external pure returns (bytes32) {\n        return EXECUTOR_TYPE;\n    }\n}\n"
    },
    "contracts/test/mocks/evmscript/EVMScriptExecutorNoReturnMock.sol": {
      "content": "pragma solidity 0.4.24;\n\n\nimport \"../../../evmscript/executors/BaseEVMScriptExecutor.sol\";\n\ncontract EVMScriptExecutorNoReturnMock is BaseEVMScriptExecutor {\n    bytes32 internal constant EXECUTOR_TYPE = keccak256(\"NO_RETURN_SCRIPT\");\n\n    function execScript(bytes, bytes, address[]) external isInitialized returns (bytes) {\n        assembly {\n            stop\n        }\n    }\n\n    function executorType() external pure returns (bytes32) {\n        return EXECUTOR_TYPE;\n    }\n}\n"
    },
    "contracts/test/mocks/evmscript/EVMScriptExecutorMock.sol": {
      "content": "pragma solidity 0.4.24;\n\n\nimport \"../../../evmscript/executors/BaseEVMScriptExecutor.sol\";\n\ncontract EVMScriptExecutorMock is BaseEVMScriptExecutor {\n    bytes32 internal constant EXECUTOR_TYPE = keccak256(\"MOCK_SCRIPT\");\n\n    function execScript(bytes _script, bytes, address[]) external isInitialized returns (bytes) {\n        // Return full input script if it's more than just the spec ID, otherwise return an empty\n        // bytes array\n        if (_script.length > SCRIPT_START_LOCATION) {\n            return _script;\n        }\n    }\n\n    function executorType() external pure returns (bytes32) {\n        return EXECUTOR_TYPE;\n    }\n}\n"
    },
    "contracts/test/mocks/common/LifecycleMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/Initializable.sol\";\nimport \"../../../common/Petrifiable.sol\";\n\n\ncontract LifecycleMock is Initializable, Petrifiable {\n    function initializeMock() public {\n        initialized();\n    }\n\n    function petrifyMock() public {\n        petrify();\n    }\n}\n"
    },
    "contracts/test/mocks/common/InitializableStorageMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/Initializable.sol\";\n\n\ncontract InitializableStorageMock is Initializable {\n    function initialize() onlyInit public {\n        initialized();\n    }\n\n    function getInitializationBlockPosition() public pure returns (bytes32) {\n        return INITIALIZATION_BLOCK_POSITION;\n    }\n}\n"
    },
    "contracts/test/mocks/apps/AppProxyPinnedStorageMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/AppProxyPinned.sol\";\nimport \"../../../kernel/IKernel.sol\";\nimport \"../../../kernel/Kernel.sol\";\n\n\ncontract FakeAppConstants {\n    bytes32 public constant FAKE_APP_ID = keccak256('FAKE_APP_ID');\n}\n\ncontract KernelPinnedStorageMock is Kernel, FakeAppConstants {\n    constructor(address _fakeApp) Kernel(false) public {\n        _setApp(KERNEL_APP_BASES_NAMESPACE, FAKE_APP_ID, _fakeApp);\n    }\n}\n\n\n// Testing this contract is a bit of a pain... we can't overload anything to make the contract check\n// pass in the constructor, so we're forced to initialize this with a mocked Kernel that already\n// sets a contract for the fake app.\ncontract AppProxyPinnedStorageMock is AppProxyPinned, FakeAppConstants {\n    constructor(KernelPinnedStorageMock _mockKernel)\n        AppProxyPinned(IKernel(_mockKernel), FAKE_APP_ID, new bytes(0))\n        public // solium-disable-line visibility-first\n    {\n    }\n\n    function setPinnedCodeExt(address _pinnedCode) public {\n        setPinnedCode(_pinnedCode);\n    }\n\n    function getPinnedCodePosition() public pure returns (bytes32) {\n        return PINNED_CODE_POSITION;\n    }\n\n    function pinnedCodeExt() public view returns (address) {\n        return pinnedCode();\n    }\n}\n"
    },
    "contracts/test/mocks/common/ReentrancyGuardMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/ReentrancyGuard.sol\";\nimport \"../../../common/UnstructuredStorage.sol\";\n\n\ncontract ReentrantActor {\n    bool reenterNonReentrant;\n\n    constructor(bool _reenterNonReentrant) public {\n        reenterNonReentrant = _reenterNonReentrant;\n    }\n\n    function reenter(ReentrancyGuardMock _mock) public {\n        // Set the reentrancy target to 0 so we don't infinite loop\n        ReentrantActor reentrancyTarget = ReentrantActor(0);\n\n        if (reenterNonReentrant) {\n            _mock.nonReentrantCall(reentrancyTarget);\n        } else {\n            _mock.reentrantCall(reentrancyTarget);\n        }\n    }\n}\n\n\ncontract ReentrancyGuardMock is ReentrancyGuard {\n    using UnstructuredStorage for bytes32;\n\n    uint256 public callCounter;\n\n    function nonReentrantCall(ReentrantActor _target) public nonReentrant {\n        callCounter++;\n        if (_target != address(0)) {\n            _target.reenter(this);\n        }\n    }\n\n    function reentrantCall(ReentrantActor _target) public {\n        callCounter++;\n        if (_target != address(0)) {\n            _target.reenter(this);\n        }\n    }\n\n    function setReentrancyMutex(bool _mutex) public {\n        getReentrancyMutexPosition().setStorageBool(_mutex);\n    }\n\n    function getReentrancyMutexPosition() public pure returns (bytes32) {\n        return keccak256(\"aragonOS.reentrancyGuard.mutex\");\n    }\n}\n"
    },
    "contracts/test/mocks/apps/AppStorageMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apps/AppStorage.sol\";\n\n\ncontract AppStorageMock is AppStorage {\n    function setKernelExt(IKernel _kernel) public {\n        setKernel(_kernel);\n    }\n\n    function setAppIdExt(bytes32 _appId) public {\n        setAppId(_appId);\n    }\n\n    function getKernelPosition() public pure returns (bytes32) {\n        return KERNEL_POSITION;\n    }\n\n    function getAppIdPosition() public pure returns (bytes32) {\n        return APP_ID_POSITION;\n    }\n}\n"
    },
    "contracts/factory/APMRegistryFactory.sol": {
      "content": "pragma solidity 0.4.24;\n\n\nimport \"../apm/APMRegistry.sol\";\nimport \"../apm/Repo.sol\";\nimport \"../ens/ENSSubdomainRegistrar.sol\";\n\nimport \"./DAOFactory.sol\";\nimport \"./ENSFactory.sol\";\nimport \"./AppProxyFactory.sol\";\n\n\ncontract APMRegistryFactory is APMInternalAppNames {\n    DAOFactory public daoFactory;\n    APMRegistry public registryBase;\n    Repo public repoBase;\n    ENSSubdomainRegistrar public ensSubdomainRegistrarBase;\n    ENS public ens;\n\n    event DeployAPM(bytes32 indexed node, address apm);\n\n    /**\n    * @notice Create a new factory for deploying Aragon Package Managers (aragonPM)\n    * @dev Requires either a given ENS registrar or ENSFactory (used for generating a new ENS in test environments).\n    * @param _daoFactory Base factory for deploying DAOs\n    * @param _registryBase APMRegistry base contract location\n    * @param _repoBase Repo base contract location\n    * @param _ensSubBase ENSSubdomainRegistrar base contract location\n    * @param _ens ENS instance\n    * @param _ensFactory ENSFactory (used to generated a new ENS if no ENS is given)\n    */\n    constructor(\n        DAOFactory _daoFactory,\n        APMRegistry _registryBase,\n        Repo _repoBase,\n        ENSSubdomainRegistrar _ensSubBase,\n        ENS _ens,\n        ENSFactory _ensFactory\n    ) public // DAO initialized without evmscript run support\n    {\n        daoFactory = _daoFactory;\n        registryBase = _registryBase;\n        repoBase = _repoBase;\n        ensSubdomainRegistrarBase = _ensSubBase;\n\n        // Either the ENS address provided is used, if any.\n        // Or we use the ENSFactory to generate a test instance of ENS\n        // If not the ENS address nor factory address are provided, this will revert\n        ens = _ens != address(0) ? _ens : _ensFactory.newENS(this);\n    }\n\n    /**\n    * @notice Create a new Aragon Package Manager (aragonPM) DAO, holding the `_label` subdomain from parent `_tld` and controlled by `_root`\n    * @param _tld The parent node of the controlled subdomain\n    * @param _label The subdomain label\n    * @param _root Manager for the new aragonPM DAO\n    * @return The new aragonPM's APMRegistry app\n    */\n    function newAPM(bytes32 _tld, bytes32 _label, address _root) public returns (APMRegistry) {\n        bytes32 node = keccak256(abi.encodePacked(_tld, _label));\n\n        // Assume it is the test ENS\n        if (ens.owner(node) != address(this)) {\n            // If we weren't in test ens and factory doesn't have ownership, will fail\n            require(ens.owner(_tld) == address(this));\n            ens.setSubnodeOwner(_tld, _label, this);\n        }\n\n        Kernel dao = daoFactory.newDAO(this);\n        ACL acl = ACL(dao.acl());\n\n        acl.createPermission(this, dao, dao.APP_MANAGER_ROLE(), this);\n\n        // Deploy app proxies\n        bytes memory noInit = new bytes(0);\n        ENSSubdomainRegistrar ensSub = ENSSubdomainRegistrar(\n            dao.newAppInstance(\n                keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(ENS_SUB_APP_NAME)))),\n                ensSubdomainRegistrarBase,\n                noInit,\n                false\n            )\n        );\n        APMRegistry apm = APMRegistry(\n            dao.newAppInstance(\n                keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(APM_APP_NAME)))),\n                registryBase,\n                noInit,\n                false\n            )\n        );\n\n        // APMRegistry controls Repos\n        bytes32 repoAppId = keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(REPO_APP_NAME))));\n        dao.setApp(dao.APP_BASES_NAMESPACE(), repoAppId, repoBase);\n\n        emit DeployAPM(node, apm);\n\n        // Grant permissions needed for APM on ENSSubdomainRegistrar\n        acl.createPermission(apm, ensSub, ensSub.CREATE_NAME_ROLE(), _root);\n        acl.createPermission(apm, ensSub, ensSub.POINT_ROOTNODE_ROLE(), _root);\n\n        // allow apm to create permissions for Repos in Kernel\n        bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n\n        acl.grantPermission(apm, acl, permRole);\n\n        // Initialize\n        ens.setOwner(node, ensSub);\n        ensSub.initialize(ens, node);\n        apm.initialize(ensSub);\n\n        uint16[3] memory firstVersion;\n        firstVersion[0] = 1;\n\n        acl.createPermission(this, apm, apm.CREATE_REPO_ROLE(), this);\n\n        apm.newRepoWithVersion(APM_APP_NAME, _root, firstVersion, registryBase, b(\"ipfs:apm\"));\n        apm.newRepoWithVersion(ENS_SUB_APP_NAME, _root, firstVersion, ensSubdomainRegistrarBase, b(\"ipfs:enssub\"));\n        apm.newRepoWithVersion(REPO_APP_NAME, _root, firstVersion, repoBase, b(\"ipfs:repo\"));\n\n        configureAPMPermissions(acl, apm, _root);\n\n        // Permission transition to _root\n        acl.setPermissionManager(_root, dao, dao.APP_MANAGER_ROLE());\n        acl.revokePermission(this, acl, permRole);\n        acl.grantPermission(_root, acl, permRole);\n        acl.setPermissionManager(_root, acl, permRole);\n\n        return apm;\n    }\n\n    function b(string memory x) internal pure returns (bytes memory y) {\n        y = bytes(x);\n    }\n\n    // Factory can be subclassed and permissions changed\n    function configureAPMPermissions(ACL _acl, APMRegistry _apm, address _root) internal {\n        _acl.grantPermission(_root, _apm, _apm.CREATE_REPO_ROLE());\n        _acl.setPermissionManager(_root, _apm, _apm.CREATE_REPO_ROLE());\n    }\n}\n"
    },
    "contracts/apm/APMRegistry.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../lib/ens/AbstractENS.sol\";\nimport \"../ens/ENSSubdomainRegistrar.sol\";\nimport \"../factory/AppProxyFactory.sol\";\nimport \"../apps/AragonApp.sol\";\nimport \"../acl/ACL.sol\";\nimport \"./Repo.sol\";\n\n\ncontract APMInternalAppNames {\n    string internal constant APM_APP_NAME = \"apm-registry\";\n    string internal constant REPO_APP_NAME = \"apm-repo\";\n    string internal constant ENS_SUB_APP_NAME = \"apm-enssub\";\n}\n\n\ncontract APMRegistry is AragonApp, AppProxyFactory, APMInternalAppNames {\n    /* Hardcoded constants to save gas\n    bytes32 public constant CREATE_REPO_ROLE = keccak256(\"CREATE_REPO_ROLE\");\n    */\n    bytes32 public constant CREATE_REPO_ROLE = 0x2a9494d64846c9fdbf0158785aa330d8bc9caf45af27fa0e8898eb4d55adcea6;\n\n    string private constant ERROR_INIT_PERMISSIONS = \"APMREG_INIT_PERMISSIONS\";\n    string private constant ERROR_EMPTY_NAME = \"APMREG_EMPTY_NAME\";\n\n    AbstractENS public ens;\n    ENSSubdomainRegistrar public registrar;\n\n    event NewRepo(bytes32 id, string name, address repo);\n\n    /**\n    * NEEDS CREATE_NAME_ROLE and POINT_ROOTNODE_ROLE permissions on registrar\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized\n    * @notice Initialize this APMRegistry instance and set `_registrar` as the ENS subdomain registrar\n    * @param _registrar ENSSubdomainRegistrar instance that holds registry root node ownership\n    */\n    function initialize(ENSSubdomainRegistrar _registrar) public onlyInit {\n        initialized();\n\n        registrar = _registrar;\n        ens = registrar.ens();\n\n        registrar.pointRootNode(this);\n\n        // Check APM has all permissions it needss\n        ACL acl = ACL(kernel().acl());\n        require(acl.hasPermission(this, registrar, registrar.CREATE_NAME_ROLE()), ERROR_INIT_PERMISSIONS);\n        require(acl.hasPermission(this, acl, acl.CREATE_PERMISSIONS_ROLE()), ERROR_INIT_PERMISSIONS);\n    }\n\n    /**\n    * @notice Create new repo in registry with `_name`\n    * @param _name Repo name, must be ununsed\n    * @param _dev Address that will be given permission to create versions\n    */\n    function newRepo(string _name, address _dev) public auth(CREATE_REPO_ROLE) returns (Repo) {\n        return _newRepo(_name, _dev);\n    }\n\n    /**\n    * @notice Create new repo in registry with `_name` and publish a first version with contract `_contractAddress` and content `@fromHex(_contentURI)`\n    * @param _name Repo name\n    * @param _dev Address that will be given permission to create versions\n    * @param _initialSemanticVersion Semantic version for new repo version\n    * @param _contractAddress address for smart contract logic for version (if set to 0, it uses last versions' contractAddress)\n    * @param _contentURI External URI for fetching new version's content\n    */\n    function newRepoWithVersion(\n        string _name,\n        address _dev,\n        uint16[3] _initialSemanticVersion,\n        address _contractAddress,\n        bytes _contentURI\n    ) public auth(CREATE_REPO_ROLE) returns (Repo)\n    {\n        Repo repo = _newRepo(_name, this); // need to have permissions to create version\n        repo.newVersion(_initialSemanticVersion, _contractAddress, _contentURI);\n\n        // Give permissions to _dev\n        ACL acl = ACL(kernel().acl());\n        acl.revokePermission(this, repo, repo.CREATE_VERSION_ROLE());\n        acl.grantPermission(_dev, repo, repo.CREATE_VERSION_ROLE());\n        acl.setPermissionManager(_dev, repo, repo.CREATE_VERSION_ROLE());\n        return repo;\n    }\n\n    function _newRepo(string _name, address _dev) internal returns (Repo) {\n        require(bytes(_name).length > 0, ERROR_EMPTY_NAME);\n\n        Repo repo = newClonedRepo();\n\n        ACL(kernel().acl()).createPermission(_dev, repo, repo.CREATE_VERSION_ROLE(), _dev);\n\n        // Creates [name] subdomain in the rootNode and sets registry as resolver\n        // This will fail if repo name already exists\n        bytes32 node = registrar.createNameAndPoint(keccak256(abi.encodePacked(_name)), repo);\n\n        emit NewRepo(node, _name, repo);\n\n        return repo;\n    }\n\n    function newClonedRepo() internal returns (Repo repo) {\n        repo = Repo(newAppProxy(kernel(), repoAppId()));\n        repo.initialize();\n    }\n\n    function repoAppId() internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(registrar.rootNode(), keccak256(abi.encodePacked(REPO_APP_NAME))));\n    }\n}\n"
    },
    "contracts/apm/Repo.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../apps/AragonApp.sol\";\n\n\n/* solium-disable function-order */\n// Allow public initialize() to be first\ncontract Repo is AragonApp {\n    /* Hardcoded constants to save gas\n    bytes32 public constant CREATE_VERSION_ROLE = keccak256(\"CREATE_VERSION_ROLE\");\n    */\n    bytes32 public constant CREATE_VERSION_ROLE = 0x1f56cfecd3595a2e6cc1a7e6cb0b20df84cdbd92eff2fee554e70e4e45a9a7d8;\n\n    string private constant ERROR_INVALID_BUMP = \"REPO_INVALID_BUMP\";\n    string private constant ERROR_INVALID_VERSION = \"REPO_INVALID_VERSION\";\n    string private constant ERROR_INEXISTENT_VERSION = \"REPO_INEXISTENT_VERSION\";\n\n    struct Version {\n        uint16[3] semanticVersion;\n        address contractAddress;\n        bytes contentURI;\n    }\n\n    uint256 internal versionsNextIndex;\n    mapping (uint256 => Version) internal versions;\n    mapping (bytes32 => uint256) internal versionIdForSemantic;\n    mapping (address => uint256) internal latestVersionIdForContract;\n\n    event NewVersion(uint256 versionId, uint16[3] semanticVersion);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized.\n    * @notice Initialize this Repo\n    */\n    function initialize() public onlyInit {\n        initialized();\n        versionsNextIndex = 1;\n    }\n\n    /**\n    * @notice Create new version with contract `_contractAddress` and content `@fromHex(_contentURI)`\n    * @param _newSemanticVersion Semantic version for new repo version\n    * @param _contractAddress address for smart contract logic for version (if set to 0, it uses last versions' contractAddress)\n    * @param _contentURI External URI for fetching new version's content\n    */\n    function newVersion(\n        uint16[3] _newSemanticVersion,\n        address _contractAddress,\n        bytes _contentURI\n    ) public auth(CREATE_VERSION_ROLE)\n    {\n        address contractAddress = _contractAddress;\n        uint256 lastVersionIndex = versionsNextIndex - 1;\n\n        uint16[3] memory lastSematicVersion;\n\n        if (lastVersionIndex > 0) {\n            Version storage lastVersion = versions[lastVersionIndex];\n            lastSematicVersion = lastVersion.semanticVersion;\n\n            if (contractAddress == address(0)) {\n                contractAddress = lastVersion.contractAddress;\n            }\n            // Only allows smart contract change on major version bumps\n            require(\n                lastVersion.contractAddress == contractAddress || _newSemanticVersion[0] > lastVersion.semanticVersion[0],\n                ERROR_INVALID_VERSION\n            );\n        }\n\n        require(isValidBump(lastSematicVersion, _newSemanticVersion), ERROR_INVALID_BUMP);\n\n        uint256 versionId = versionsNextIndex++;\n        versions[versionId] = Version(_newSemanticVersion, contractAddress, _contentURI);\n        versionIdForSemantic[semanticVersionHash(_newSemanticVersion)] = versionId;\n        latestVersionIdForContract[contractAddress] = versionId;\n\n        emit NewVersion(versionId, _newSemanticVersion);\n    }\n\n    function getLatest() public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n        return getByVersionId(versionsNextIndex - 1);\n    }\n\n    function getLatestForContractAddress(address _contractAddress)\n        public\n        view\n        returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI)\n    {\n        return getByVersionId(latestVersionIdForContract[_contractAddress]);\n    }\n\n    function getBySemanticVersion(uint16[3] _semanticVersion)\n        public\n        view\n        returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI)\n    {\n        return getByVersionId(versionIdForSemantic[semanticVersionHash(_semanticVersion)]);\n    }\n\n    function getByVersionId(uint _versionId) public view returns (uint16[3] semanticVersion, address contractAddress, bytes contentURI) {\n        require(_versionId > 0 && _versionId < versionsNextIndex, ERROR_INEXISTENT_VERSION);\n        Version storage version = versions[_versionId];\n        return (version.semanticVersion, version.contractAddress, version.contentURI);\n    }\n\n    function getVersionsCount() public view returns (uint256) {\n        return versionsNextIndex - 1;\n    }\n\n    function isValidBump(uint16[3] _oldVersion, uint16[3] _newVersion) public pure returns (bool) {\n        bool hasBumped;\n        uint i = 0;\n        while (i < 3) {\n            if (hasBumped) {\n                if (_newVersion[i] != 0) {\n                    return false;\n                }\n            } else if (_newVersion[i] != _oldVersion[i]) {\n                if (_oldVersion[i] > _newVersion[i] || _newVersion[i] - _oldVersion[i] != 1) {\n                    return false;\n                }\n                hasBumped = true;\n            }\n            i++;\n        }\n        return hasBumped;\n    }\n\n    function semanticVersionHash(uint16[3] version) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(version[0], version[1], version[2]));\n    }\n}\n"
    },
    "contracts/ens/ENSSubdomainRegistrar.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../lib/ens/AbstractENS.sol\";\nimport \"../lib/ens/PublicResolver.sol\";\nimport \"./ENSConstants.sol\";\n\nimport \"../apps/AragonApp.sol\";\n\n\n/* solium-disable function-order */\n// Allow public initialize() to be first\ncontract ENSSubdomainRegistrar is AragonApp, ENSConstants {\n    /* Hardcoded constants to save gas\n    bytes32 public constant CREATE_NAME_ROLE = keccak256(\"CREATE_NAME_ROLE\");\n    bytes32 public constant DELETE_NAME_ROLE = keccak256(\"DELETE_NAME_ROLE\");\n    bytes32 public constant POINT_ROOTNODE_ROLE = keccak256(\"POINT_ROOTNODE_ROLE\");\n    */\n    bytes32 public constant CREATE_NAME_ROLE = 0xf86bc2abe0919ab91ef714b2bec7c148d94f61fdb069b91a6cfe9ecdee1799ba;\n    bytes32 public constant DELETE_NAME_ROLE = 0x03d74c8724218ad4a99859bcb2d846d39999449fd18013dd8d69096627e68622;\n    bytes32 public constant POINT_ROOTNODE_ROLE = 0x9ecd0e7bddb2e241c41b595a436c4ea4fd33c9fa0caa8056acf084fc3aa3bfbe;\n\n    string private constant ERROR_NO_NODE_OWNERSHIP = \"ENSSUB_NO_NODE_OWNERSHIP\";\n    string private constant ERROR_NAME_EXISTS = \"ENSSUB_NAME_EXISTS\";\n    string private constant ERROR_NAME_DOESNT_EXIST = \"ENSSUB_DOESNT_EXIST\";\n\n    AbstractENS public ens;\n    bytes32 public rootNode;\n\n    event NewName(bytes32 indexed node, bytes32 indexed label);\n    event DeleteName(bytes32 indexed node, bytes32 indexed label);\n\n    /**\n    * @dev Initialize can only be called once. It saves the block number in which it was initialized. This contract must be the owner of the `_rootNode` node so that it can create subdomains.\n    * @notice Initialize this ENSSubdomainRegistrar instance with `_ens` as the root ENS registry and `_rootNode` as the node to allocate subdomains under\n    * @param _ens Address of ENS registry\n    * @param _rootNode Node to allocate subdomains under\n    */\n    function initialize(AbstractENS _ens, bytes32 _rootNode) public onlyInit {\n        initialized();\n\n        // We need ownership to create subnodes\n        require(_ens.owner(_rootNode) == address(this), ERROR_NO_NODE_OWNERSHIP);\n\n        ens = _ens;\n        rootNode = _rootNode;\n    }\n\n    /**\n    * @notice Create a new ENS subdomain record for `_label` and assign ownership to `_owner`\n    * @param _label Label of new subdomain\n    * @param _owner Owner of new subdomain\n    * @return node Hash of created node\n    */\n    function createName(bytes32 _label, address _owner) external auth(CREATE_NAME_ROLE) returns (bytes32 node) {\n        return _createName(_label, _owner);\n    }\n\n    /**\n    * @notice Create a new ENS subdomain record for `_label` that resolves to `_target` and is owned by this ENSSubdomainRegistrar\n    * @param _label Label of new subdomain\n    * @param _target Ethereum address this new subdomain label will point to\n    * @return node Hash of created node\n    */\n    function createNameAndPoint(bytes32 _label, address _target) external auth(CREATE_NAME_ROLE) returns (bytes32 node) {\n        node = _createName(_label, this);\n        _pointToResolverAndResolve(node, _target);\n    }\n\n    /**\n    * @notice Deregister ENS subdomain record for `_label`\n    * @param _label Label of subdomain to deregister\n    */\n    function deleteName(bytes32 _label) external auth(DELETE_NAME_ROLE) {\n        bytes32 node = getNodeForLabel(_label);\n\n        address currentOwner = ens.owner(node);\n\n        require(currentOwner != address(0), ERROR_NAME_DOESNT_EXIST); // fail if deleting unset name\n\n        if (currentOwner != address(this)) { // needs to reclaim ownership so it can set resolver\n            ens.setSubnodeOwner(rootNode, _label, this);\n        }\n\n        ens.setResolver(node, address(0)); // remove resolver so it ends resolving\n        ens.setOwner(node, address(0));\n\n        emit DeleteName(node, _label);\n    }\n\n    /**\n    * @notice Resolve this ENSSubdomainRegistrar's root node to `_target`\n    * @param _target Ethereum address root node will point to\n    */\n    function pointRootNode(address _target) external auth(POINT_ROOTNODE_ROLE) {\n        _pointToResolverAndResolve(rootNode, _target);\n    }\n\n    function _createName(bytes32 _label, address _owner) internal returns (bytes32 node) {\n        node = getNodeForLabel(_label);\n        require(ens.owner(node) == address(0), ERROR_NAME_EXISTS); // avoid name reset\n\n        ens.setSubnodeOwner(rootNode, _label, _owner);\n\n        emit NewName(node, _label);\n\n        return node;\n    }\n\n    function _pointToResolverAndResolve(bytes32 _node, address _target) internal {\n        address publicResolver = getAddr(PUBLIC_RESOLVER_NODE);\n        ens.setResolver(_node, publicResolver);\n\n        PublicResolver(publicResolver).setAddr(_node, _target);\n    }\n\n    function getAddr(bytes32 node) internal view returns (address) {\n        address resolver = ens.resolver(node);\n        return PublicResolver(resolver).addr(node);\n    }\n\n    function getNodeForLabel(bytes32 _label) internal view returns (bytes32) {\n        return keccak256(abi.encodePacked(rootNode, _label));\n    }\n}\n"
    },
    "contracts/factory/DAOFactory.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../kernel/IKernel.sol\";\nimport \"../kernel/Kernel.sol\";\nimport \"../kernel/KernelProxy.sol\";\n\nimport \"../acl/IACL.sol\";\nimport \"../acl/ACL.sol\";\n\nimport \"./EVMScriptRegistryFactory.sol\";\n\n\ncontract DAOFactory {\n    IKernel public baseKernel;\n    IACL public baseACL;\n    EVMScriptRegistryFactory public regFactory;\n\n    event DeployDAO(address dao);\n    event DeployEVMScriptRegistry(address reg);\n\n    /**\n    * @notice Create a new DAOFactory, creating DAOs with Kernels proxied to `_baseKernel`, ACLs proxied to `_baseACL`, and new EVMScriptRegistries created from `_regFactory`.\n    * @param _baseKernel Base Kernel\n    * @param _baseACL Base ACL\n    * @param _regFactory EVMScriptRegistry factory\n    */\n    constructor(IKernel _baseKernel, IACL _baseACL, EVMScriptRegistryFactory _regFactory) public {\n        // No need to init as it cannot be killed by devops199\n        if (address(_regFactory) != address(0)) {\n            regFactory = _regFactory;\n        }\n\n        baseKernel = _baseKernel;\n        baseACL = _baseACL;\n    }\n\n    /**\n    * @notice Create a new DAO with `_root` set as the initial admin\n    * @param _root Address that will be granted control to setup DAO permissions\n    * @return Newly created DAO\n    */\n    function newDAO(address _root) public returns (Kernel) {\n        Kernel dao = Kernel(new KernelProxy(baseKernel));\n\n        if (address(regFactory) == address(0)) {\n            dao.initialize(baseACL, _root);\n        } else {\n            dao.initialize(baseACL, this);\n\n            ACL acl = ACL(dao.acl());\n            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n            bytes32 appManagerRole = dao.APP_MANAGER_ROLE();\n\n            acl.grantPermission(regFactory, acl, permRole);\n\n            acl.createPermission(regFactory, dao, appManagerRole, this);\n\n            EVMScriptRegistry reg = regFactory.newEVMScriptRegistry(dao);\n            emit DeployEVMScriptRegistry(address(reg));\n\n            // Clean up permissions\n            // First, completely reset the APP_MANAGER_ROLE\n            acl.revokePermission(regFactory, dao, appManagerRole);\n            acl.removePermissionManager(dao, appManagerRole);\n\n            // Then, make root the only holder and manager of CREATE_PERMISSIONS_ROLE\n            acl.revokePermission(regFactory, acl, permRole);\n            acl.revokePermission(this, acl, permRole);\n            acl.grantPermission(_root, acl, permRole);\n            acl.setPermissionManager(_root, acl, permRole);\n        }\n\n        emit DeployDAO(address(dao));\n\n        return dao;\n    }\n}\n"
    },
    "contracts/factory/ENSFactory.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../lib/ens/ENS.sol\";\nimport \"../lib/ens/PublicResolver.sol\";\nimport \"../ens/ENSConstants.sol\";\n\n\n// WARNING: This is an incredibly trustful ENS deployment, do NOT use in production!\n// This contract is NOT meant to be deployed to a live network.\n// Its only purpose is to easily create ENS instances for testing aragonPM.\ncontract ENSFactory is ENSConstants {\n    event DeployENS(address ens);\n\n    /**\n    * @notice Create a new ENS and set `_owner` as the owner of the top level domain.\n    * @param _owner Owner of .eth\n    * @return ENS\n    */\n    function newENS(address _owner) public returns (ENS) {\n        ENS ens = new ENS();\n\n        // Setup .eth TLD\n        ens.setSubnodeOwner(ENS_ROOT, ETH_TLD_LABEL, this);\n\n        // Setup public resolver\n        PublicResolver resolver = new PublicResolver(ens);\n        ens.setSubnodeOwner(ETH_TLD_NODE, PUBLIC_RESOLVER_LABEL, this);\n        ens.setResolver(PUBLIC_RESOLVER_NODE, resolver);\n        resolver.setAddr(PUBLIC_RESOLVER_NODE, resolver);\n\n        ens.setOwner(ETH_TLD_NODE, _owner);\n        ens.setOwner(ENS_ROOT, _owner);\n\n        emit DeployENS(ens);\n\n        return ens;\n    }\n}\n"
    },
    "contracts/lib/ens/AbstractENS.sol": {
      "content": "// See https://github.com/ensdomains/ens/blob/7e377df83f/contracts/AbstractENS.sol\n\npragma solidity ^0.4.15;\n\n\ninterface AbstractENS {\n    function owner(bytes32 _node) public constant returns (address);\n    function resolver(bytes32 _node) public constant returns (address);\n    function ttl(bytes32 _node) public constant returns (uint64);\n    function setOwner(bytes32 _node, address _owner) public;\n    function setSubnodeOwner(bytes32 _node, bytes32 label, address _owner) public;\n    function setResolver(bytes32 _node, address _resolver) public;\n    function setTTL(bytes32 _node, uint64 _ttl) public;\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed _node, bytes32 indexed _label, address _owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed _node, address _owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed _node, address _resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed _node, uint64 _ttl);\n}\n"
    },
    "contracts/lib/ens/PublicResolver.sol": {
      "content": "// See https://github.com/ensdomains/ens/blob/7e377df83f/contracts/PublicResolver.sol\n\npragma solidity ^0.4.0;\n\nimport \"./AbstractENS.sol\";\n\n/**\n * A simple resolver anyone can use; only allows the owner of a node to set its\n * address.\n */\ncontract PublicResolver {\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\n\n    event AddrChanged(bytes32 indexed node, address a);\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n    event NameChanged(bytes32 indexed node, string name);\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\n\n    struct PublicKey {\n        bytes32 x;\n        bytes32 y;\n    }\n\n    struct Record {\n        address addr;\n        bytes32 content;\n        string name;\n        PublicKey pubkey;\n        mapping(string=>string) text;\n        mapping(uint256=>bytes) abis;\n    }\n\n    AbstractENS ens;\n    mapping(bytes32=>Record) records;\n\n    modifier only_owner(bytes32 node) {\n        if (ens.owner(node) != msg.sender) throw;\n        _;\n    }\n\n    /**\n     * Constructor.\n     * @param ensAddr The ENS registrar contract.\n     */\n    function PublicResolver(AbstractENS ensAddr) public {\n        ens = ensAddr;\n    }\n\n    /**\n     * Returns true if the resolver implements the interface specified by the provided hash.\n     * @param interfaceID The ID of the interface to check for.\n     * @return True if the contract implements the requested interface.\n     */\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return interfaceID == ADDR_INTERFACE_ID ||\n               interfaceID == CONTENT_INTERFACE_ID ||\n               interfaceID == NAME_INTERFACE_ID ||\n               interfaceID == ABI_INTERFACE_ID ||\n               interfaceID == PUBKEY_INTERFACE_ID ||\n               interfaceID == TEXT_INTERFACE_ID ||\n               interfaceID == INTERFACE_META_ID;\n    }\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) public constant returns (address ret) {\n        ret = records[node].addr;\n    }\n\n    /**\n     * Sets the address associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param addr The address to set.\n     */\n    function setAddr(bytes32 node, address addr) only_owner(node) public {\n        records[node].addr = addr;\n        AddrChanged(node, addr);\n    }\n\n    /**\n     * Returns the content hash associated with an ENS node.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The ENS node to query.\n     * @return The associated content hash.\n     */\n    function content(bytes32 node) public constant returns (bytes32 ret) {\n        ret = records[node].content;\n    }\n\n    /**\n     * Sets the content hash associated with an ENS node.\n     * May only be called by the owner of that node in the ENS registry.\n     * Note that this resource type is not standardized, and will likely change\n     * in future to a resource type based on multihash.\n     * @param node The node to update.\n     * @param hash The content hash to set\n     */\n    function setContent(bytes32 node, bytes32 hash) only_owner(node) public {\n        records[node].content = hash;\n        ContentChanged(node, hash);\n    }\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) public constant returns (string ret) {\n        ret = records[node].name;\n    }\n\n    /**\n     * Sets the name associated with an ENS node, for reverse records.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param name The name to set.\n     */\n    function setName(bytes32 node, string name) only_owner(node) public {\n        records[node].name = name;\n        NameChanged(node, name);\n    }\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(bytes32 node, uint256 contentTypes) public constant returns (uint256 contentType, bytes data) {\n        var record = records[node];\n        for(contentType = 1; contentType <= contentTypes; contentType <<= 1) {\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\n                data = record.abis[contentType];\n                return;\n            }\n        }\n        contentType = 0;\n    }\n\n    /**\n     * Sets the ABI associated with an ENS node.\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\n     * the empty string.\n     * @param node The node to update.\n     * @param contentType The content type of the ABI\n     * @param data The ABI data.\n     */\n    function setABI(bytes32 node, uint256 contentType, bytes data) only_owner(node) public {\n        // Content types must be powers of 2\n        if (((contentType - 1) & contentType) != 0) throw;\n\n        records[node].abis[contentType] = data;\n        ABIChanged(node, contentType);\n    }\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x, y the X and Y coordinates of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) public constant returns (bytes32 x, bytes32 y) {\n        return (records[node].pubkey.x, records[node].pubkey.y);\n    }\n\n    /**\n     * Sets the SECP256k1 public key associated with an ENS node.\n     * @param node The ENS node to query\n     * @param x the X coordinate of the curve point for the public key.\n     * @param y the Y coordinate of the curve point for the public key.\n     */\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) only_owner(node) public {\n        records[node].pubkey = PublicKey(x, y);\n        PubkeyChanged(node, x, y);\n    }\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(bytes32 node, string key) public constant returns (string ret) {\n        ret = records[node].text[key];\n    }\n\n    /**\n     * Sets the text data associated with an ENS node and key.\n     * May only be called by the owner of that node in the ENS registry.\n     * @param node The node to update.\n     * @param key The key to set.\n     * @param value The text data value to set.\n     */\n    function setText(bytes32 node, string key, string value) only_owner(node) public {\n        records[node].text[key] = value;\n        TextChanged(node, key, key);\n    }\n}\n"
    },
    "contracts/ens/ENSConstants.sol": {
      "content": "/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ENSConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant ENS_ROOT = bytes32(0);\n    bytes32 internal constant ETH_TLD_LABEL = keccak256(\"eth\");\n    bytes32 internal constant ETH_TLD_NODE = keccak256(abi.encodePacked(ENS_ROOT, ETH_TLD_LABEL));\n    bytes32 internal constant PUBLIC_RESOLVER_LABEL = keccak256(\"resolver\");\n    bytes32 internal constant PUBLIC_RESOLVER_NODE = keccak256(abi.encodePacked(ETH_TLD_NODE, PUBLIC_RESOLVER_LABEL));\n    */\n    bytes32 internal constant ENS_ROOT = bytes32(0);\n    bytes32 internal constant ETH_TLD_LABEL = 0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0;\n    bytes32 internal constant ETH_TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    bytes32 internal constant PUBLIC_RESOLVER_LABEL = 0x329539a1d23af1810c48a07fe7fc66a3b34fbc8b37e9b3cdb97bb88ceab7e4bf;\n    bytes32 internal constant PUBLIC_RESOLVER_NODE = 0xfdd5d5de6dd63db72bbc2d487944ba13bf775b50a80805fe6fcaba9b0fba88f5;\n}\n"
    },
    "contracts/lib/ens/ENS.sol": {
      "content": "// See https://github.com/ensdomains/ens/blob/7e377df83f/contracts/ENS.sol\n\npragma solidity ^0.4.0;\n\n\nimport \"./AbstractENS.sol\";\n\n/**\n * The ENS registry contract.\n */\ncontract ENS is AbstractENS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        if (records[node].owner != msg.sender) throw;\n        _;\n    }\n\n    /**\n     * Constructs a new ENS registrar.\n     */\n    function ENS() public {\n        records[0].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) public constant returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) public constant returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) public constant returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) only_owner(node) public {\n        Transfer(node, owner);\n        records[node].owner = owner;\n    }\n\n    /**\n     * Transfers ownership of a subnode keccak256(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) public {\n        var subnode = keccak256(node, label);\n        NewOwner(node, label, owner);\n        records[subnode].owner = owner;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) only_owner(node) public {\n        NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) only_owner(node) public {\n        NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n}\n"
    },
    "contracts/test/mocks/factory/APMRegistryFactoryMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apm/APMRegistry.sol\";\nimport \"../../../apm/Repo.sol\";\nimport \"../../../ens/ENSSubdomainRegistrar.sol\";\n\nimport \"../../../factory/DAOFactory.sol\";\nimport \"../../../factory/ENSFactory.sol\";\n\n// Mock that doesn't grant enough permissions\n// Only usable with new ENS instance\n\ncontract APMRegistryFactoryMock is APMInternalAppNames {\n    DAOFactory public daoFactory;\n    APMRegistry public registryBase;\n    Repo public repoBase;\n    ENSSubdomainRegistrar public ensSubdomainRegistrarBase;\n    ENS public ens;\n\n    constructor(\n        DAOFactory _daoFactory,\n        APMRegistry _registryBase,\n        Repo _repoBase,\n        ENSSubdomainRegistrar _ensSubBase,\n        ENSFactory _ensFactory\n    ) public\n    {\n        daoFactory = _daoFactory;\n        registryBase = _registryBase;\n        repoBase = _repoBase;\n        ensSubdomainRegistrarBase = _ensSubBase;\n        ens = _ensFactory.newENS(this);\n    }\n\n    function newFailingAPM(\n        bytes32 _tld,\n        bytes32 _label,\n        address _root,\n        bool _withoutNameRole\n    )\n        public\n        returns (APMRegistry)\n    {\n        // Set up ENS control\n        bytes32 node = keccak256(abi.encodePacked(_tld, _label));\n        ens.setSubnodeOwner(_tld, _label, this);\n\n        Kernel dao = daoFactory.newDAO(this);\n        ACL acl = ACL(dao.acl());\n\n        acl.createPermission(this, dao, dao.APP_MANAGER_ROLE(), this);\n\n        // Deploy app proxies\n        bytes memory noInit = new bytes(0);\n        ENSSubdomainRegistrar ensSub = ENSSubdomainRegistrar(\n            dao.newAppInstance(\n                keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(ENS_SUB_APP_NAME)))),\n                ensSubdomainRegistrarBase,\n                noInit,\n                false\n            )\n        );\n        APMRegistry apm = APMRegistry(\n            dao.newAppInstance(\n                keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(APM_APP_NAME)))),\n                registryBase,\n                noInit,\n                false\n            )\n        );\n\n        // APMRegistry controls Repos\n        bytes32 repoAppId = keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(REPO_APP_NAME))));\n        dao.setApp(dao.APP_BASES_NAMESPACE(), repoAppId, repoBase);\n\n        // Grant permissions needed for APM on ENSSubdomainRegistrar\n        acl.createPermission(apm, ensSub, ensSub.POINT_ROOTNODE_ROLE(), _root);\n\n        // Don't grant all permissions needed for APM to initialize\n        if (_withoutNameRole) {\n            acl.createPermission(apm, ensSub, ensSub.CREATE_NAME_ROLE(), _root);\n        }\n\n        if (!_withoutNameRole) {\n            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();\n            acl.grantPermission(apm, acl, permRole);\n        }\n\n        // Initialize\n        ens.setOwner(node, ensSub);\n        ensSub.initialize(ens, node);\n\n        // This should fail since we haven't given all required permissions\n        apm.initialize(ensSub);\n\n        return apm;\n    }\n}\n"
    },
    "contracts/test/mocks/ens/ENSConstantsMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../ens/ENSConstants.sol\";\n\n\ncontract ENSConstantsMock is ENSConstants {\n    function getEnsRoot() external pure returns (bytes32) { return ENS_ROOT; }\n    function getEthTldLabel() external pure returns (bytes32) { return ETH_TLD_LABEL; }\n    function getEthTldNode() external pure returns (bytes32) { return ETH_TLD_NODE; }\n    function getPublicResolverLabel() external pure returns (bytes32) { return PUBLIC_RESOLVER_LABEL; }\n    function getPublicResolverNode() external pure returns (bytes32) { return PUBLIC_RESOLVER_NODE; }\n}\n"
    },
    "contracts/id/FIFSResolvingRegistrar.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../lib/ens/AbstractENS.sol\";\nimport \"../lib/ens/IPublicResolver.sol\";\nimport \"./IFIFSResolvingRegistrar.sol\";\n\n\n/**\n * A registrar that allocates subdomains and sets resolvers to the first person to claim them.\n *\n * Adapted from ENS' FIFSRegistrar:\n *   https://github.com/ethereum/ens/blob/master/contracts/FIFSRegistrar.sol\n */\ncontract FIFSResolvingRegistrar is IFIFSResolvingRegistrar {\n    bytes32 public rootNode;\n    AbstractENS internal ens;\n    IPublicResolver internal defaultResolver;\n\n    bytes4 private constant ADDR_INTERFACE_ID = 0x3b3b57de;\n\n    event ClaimSubdomain(bytes32 indexed subnode, address indexed owner, address indexed resolver);\n\n    /**\n     * Constructor.\n     * @param _ensAddr The address of the ENS registry.\n     * @param _defaultResolver The address of the default resolver to use for subdomains.\n     * @param _node The node that this registrar administers.\n     */\n    constructor(AbstractENS _ensAddr, IPublicResolver _defaultResolver, bytes32 _node)\n        public\n    {\n        ens = _ensAddr;\n        defaultResolver = _defaultResolver;\n        rootNode = _node;\n    }\n\n    /**\n     * Register a subdomain with the default resolver if it hasn't been claimed yet.\n     * @param _subnode The hash of the label to register.\n     * @param _owner The address of the new owner.\n     */\n    function register(bytes32 _subnode, address _owner) external {\n        registerWithResolver(_subnode, _owner, defaultResolver);\n    }\n\n    /**\n     * Register a subdomain if it hasn't been claimed yet.\n     * @param _subnode The hash of the label to register.\n     * @param _owner The address of the new owner.\n     * @param _resolver The address of the resolver.\n     *                  If the resolver supports the address interface, the subdomain's address will\n     *                  be set to the new owner.\n     */\n    function registerWithResolver(bytes32 _subnode, address _owner, IPublicResolver _resolver) public {\n        bytes32 node = keccak256(rootNode, _subnode);\n        address currentOwner = ens.owner(node);\n        require(currentOwner == address(0));\n\n        ens.setSubnodeOwner(rootNode, _subnode, address(this));\n        ens.setResolver(node, _resolver);\n        if (_resolver.supportsInterface(ADDR_INTERFACE_ID)) {\n            _resolver.setAddr(node, _owner);\n        }\n\n        // Give ownership to the claimer\n        ens.setOwner(node, _owner);\n\n        emit ClaimSubdomain(_subnode, _owner, address(_resolver));\n    }\n}\n"
    },
    "contracts/lib/ens/IPublicResolver.sol": {
      "content": "pragma solidity ^0.4.0;\n\n\ninterface IPublicResolver {\n    function supportsInterface(bytes4 interfaceID) constant returns (bool);\n    function addr(bytes32 node) constant returns (address ret);\n    function setAddr(bytes32 node, address addr);\n    function hash(bytes32 node) constant returns (bytes32 ret);\n    function setHash(bytes32 node, bytes32 hash);\n}\n"
    },
    "contracts/id/IFIFSResolvingRegistrar.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../lib/ens/IPublicResolver.sol\";\n\n\ninterface IFIFSResolvingRegistrar {\n    function register(bytes32 _subnode, address _owner) external;\n    function registerWithResolver(bytes32 _subnode, address _owner, IPublicResolver _resolver) public;\n}\n"
    },
    "contracts/test/mocks/apm/UnsafeRepo.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../apm/Repo.sol\";\nimport \"../../../apps/UnsafeAragonApp.sol\";\n\n\n// Allows Repo to be used without a proxy or access controls\ncontract UnsafeRepo is Repo, UnsafeAragonApp {\n    // Protected actions are always performable\n    function canPerform(address, bytes32, uint256[]) public view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/mocks/common/TimeHelpersMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/TimeHelpers.sol\";\n\n\ncontract TimeHelpersMock is TimeHelpers {\n    function getBlockNumberDirect() public view returns (uint256) {\n        return block.number;\n    }\n\n    function getBlockNumberExt() public view returns (uint256) {\n        return getBlockNumber();\n    }\n\n    function getBlockNumber64Ext() public view returns (uint64) {\n        return getBlockNumber64();\n    }\n\n    function getTimestampDirect() public view returns (uint256) {\n        return now;\n    }\n\n    function getTimestampExt() public view returns (uint256) {\n        return getTimestamp();\n    }\n\n    function getTimestamp64Ext() public view returns (uint64) {\n        return getTimestamp64();\n    }\n}\n"
    },
    "contracts/test/mocks/common/Uint256Mock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/Uint256Helpers.sol\";\n\n\ncontract Uint256Mock {\n    using Uint256Helpers for uint256;\n\n    function convert(uint256 a) public pure returns (uint64) {\n        return a.toUint64();\n    }\n}\n"
    },
    "contracts/test/mocks/lib/token/SafeERC20Mock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../../common/SafeERC20.sol\";\nimport \"../../../../lib/token/ERC20.sol\";\n\n\ncontract SafeERC20Mock {\n    using SafeERC20 for ERC20;\n    event Result(bool result);\n\n    function transfer(ERC20 token, address to, uint256 amount) external returns (bool) {\n        bool result = token.safeTransfer(to, amount);\n        emit Result(result);\n        return result;\n    }\n\n    function transferFrom(ERC20 token, address from, address to, uint256 amount) external returns (bool) {\n        bool result = token.safeTransferFrom(from, to, amount);\n        emit Result(result);\n        return result;\n    }\n\n    function approve(ERC20 token, address spender, uint256 amount) external returns (bool) {\n        bool result = token.safeApprove(spender, amount);\n        emit Result(result);\n        return result;\n    }\n\n    function allowance(ERC20 token, address owner, address spender) external view returns (uint256) {\n        return token.staticAllowance(owner, spender);\n    }\n\n    function balanceOf(ERC20 token, address owner) external view returns (uint256) {\n        return token.staticBalanceOf(owner);\n    }\n\n    function totalSupply(ERC20 token) external view returns (uint256) {\n        return token.staticTotalSupply();\n    }\n}\n"
    },
    "contracts/test/mocks/common/EtherTokenConstantMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../common/EtherTokenConstant.sol\";\n\n\ncontract EtherTokenConstantMock is EtherTokenConstant {\n    function getETHConstant() external pure returns (address) { return ETH; }\n}\n"
    },
    "contracts/test/tests/TestConversionHelpers.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../helpers/Assert.sol\";\nimport \"../helpers/ThrowProxy.sol\";\n\nimport \"../../common/ConversionHelpers.sol\";\n\n\ncontract InvalidBytesLengthConversionThrows {\n    function tryConvertLength(uint256 _badLength) public {\n        bytes memory arr = new bytes(_badLength);\n\n        // Do failing conversion\n        uint256[] memory arrUint = ConversionHelpers.dangerouslyCastBytesToUintArray(arr);\n    }\n}\n\n\ncontract TestConversionHelpers {\n    uint256 constant internal FIRST = uint256(keccak256(\"0\"));\n    uint256 constant internal SECOND = uint256(keccak256(\"1\"));\n    uint256 constant internal THIRD = uint256(keccak256(\"2\"));\n\n    function testUintArrayConvertedToBytes() public {\n        uint256[] memory arr = new uint256[](3);\n        arr[0] = FIRST;\n        arr[1] = SECOND;\n        arr[2] = THIRD;\n        uint256 arrLength = arr.length;\n\n        // Do conversion\n        bytes memory arrBytes = ConversionHelpers.dangerouslyCastUintArrayToBytes(arr);\n\n        // Check length\n        Assert.equal(arrBytes.length, arrLength * 32, \"should have correct length as bytes array\");\n\n        // Check values\n        assertValues(arrBytes);\n\n        // Check memory position (conversion should be in place)\n        uint256 arrMemLoc;\n        uint256 arrBytesMemLoc;\n        assembly {\n            arrMemLoc := arr\n            arrBytesMemLoc := arrBytes\n        }\n        Assert.equal(arrMemLoc, arrBytesMemLoc, \"should have same memory location after conversion\");\n    }\n\n    function testUintArrayIntactIfConvertedBack() public {\n        uint256[] memory arr = new uint256[](3);\n        arr[0] = FIRST;\n        arr[1] = SECOND;\n        arr[2] = THIRD;\n        uint256 arrLength = arr.length;\n\n        // Convert to and back\n        bytes memory arrBytes = ConversionHelpers.dangerouslyCastUintArrayToBytes(arr);\n        uint256[] memory arrReconverted = ConversionHelpers.dangerouslyCastBytesToUintArray(arrBytes);\n\n        // Check length\n        Assert.equal(arrLength, arrReconverted.length, \"should have correct length after reconverting\");\n\n        // Check values\n        assertValues(arrReconverted);\n\n        // Check memory position (conversion should be in place)\n        uint256 arrMemLoc;\n        uint256 arrReconvertedMemLoc;\n        assembly {\n            arrMemLoc := arr\n            arrReconvertedMemLoc := arrReconverted\n        }\n        Assert.equal(arrMemLoc, arrReconvertedMemLoc, \"should have same memory location after reconverting\");\n    }\n\n    function testBytesConvertedToUintArray() public {\n        bytes memory arr = new bytes(96);\n\n        // Fill in bytes arr\n        uint256 first = FIRST;\n        uint256 second = SECOND;\n        uint256 third = THIRD;\n        assembly {\n            mstore(add(arr, 0x20), first)\n            mstore(add(arr, 0x40), second)\n            mstore(add(arr, 0x60), third)\n        }\n        uint256 arrLength = arr.length;\n\n        // Do conversion\n        uint256[] memory arrUint = ConversionHelpers.dangerouslyCastBytesToUintArray(arr);\n\n        // Check length\n        Assert.equal(arrUint.length, arrLength / 32, \"should have correct length as uint256 array\");\n\n        // Check values\n        assertValues(arrUint);\n\n        // Check memory position (conversion should be in place)\n        uint256 arrMemLoc;\n        uint256 arrUintMemLoc;\n        assembly {\n            arrMemLoc := arr\n            arrUintMemLoc := arrUint\n        }\n        Assert.equal(arrMemLoc, arrUintMemLoc, \"should have same memory location after conversion\");\n    }\n\n    function testBytesIntactIfConvertedBack() public {\n        bytes memory arr = new bytes(96);\n\n        // Fill in bytes arr\n        uint256 first = FIRST;\n        uint256 second = SECOND;\n        uint256 third = THIRD;\n        assembly {\n            mstore(add(arr, 0x20), first)\n            mstore(add(arr, 0x40), second)\n            mstore(add(arr, 0x60), third)\n        }\n        uint256 arrLength = arr.length;\n\n        // Convert to and back\n        uint256[] memory arrUint = ConversionHelpers.dangerouslyCastBytesToUintArray(arr);\n        bytes memory arrReconverted = ConversionHelpers.dangerouslyCastUintArrayToBytes(arrUint);\n\n        // Check length\n        Assert.equal(arrLength, arrReconverted.length, \"should have correct length after reconverting\");\n\n        // Check values\n        assertValues(arrReconverted);\n\n        // Check memory position (conversion should be in place)\n        uint256 arrMemLoc;\n        uint256 arrReconvertedMemLoc;\n        assembly {\n            arrMemLoc := arr\n            arrReconvertedMemLoc := arrReconverted\n        }\n        Assert.equal(arrMemLoc, arrReconvertedMemLoc, \"should have same memory location after reconverting\");\n    }\n\n    function testBytesConversionThrowsOnInvalidLength() public {\n        InvalidBytesLengthConversionThrows thrower = new InvalidBytesLengthConversionThrows();\n        ThrowProxy throwProxy = new ThrowProxy(address(thrower));\n\n        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(15);\n        throwProxy.assertThrows(\"should have reverted due to invalid length\");\n\n        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(36);\n        throwProxy.assertThrows(\"should have reverted due to invalid length\");\n\n        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(61);\n        throwProxy.assertThrows(\"should have reverted due to invalid length\");\n\n        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(128);\n        throwProxy.assertItDoesntThrow(\"should not have reverted as length was valid\");\n    }\n\n    function assertValues(uint256[] memory _data) public {\n        Assert.equal(_data[0], FIRST, \"should have correct index value at 0\");\n        Assert.equal(_data[1], SECOND, \"should have correct index value at 1\");\n        Assert.equal(_data[2], THIRD, \"should have correct index value at 2\");\n    }\n\n    function assertValues(bytes memory _data) public {\n        uint256 first;\n        uint256 second;\n        uint256 third;\n        assembly {\n            first := mload(add(_data, 0x20))\n            second := mload(add(_data, 0x40))\n            third := mload(add(_data, 0x60))\n        }\n        Assert.equal(first, FIRST, \"should have correct first value\");\n        Assert.equal(second, SECOND, \"should have correct second value\");\n        Assert.equal(third, THIRD, \"should have correct third value\");\n    }\n}\n"
    },
    "contracts/test/mocks/kernel/KernelConstantsMock.sol": {
      "content": "pragma solidity 0.4.24;\n\nimport \"../../../kernel/Kernel.sol\";\n\n\ncontract KernelConstantsMock is Kernel {\n    constructor() public Kernel(false) { }\n\n    function getKernelCoreNamespace() external pure returns (bytes32) { return KERNEL_CORE_NAMESPACE; }\n    function getKernelAppBasesNamespace() external pure returns (bytes32) { return KERNEL_APP_BASES_NAMESPACE; }\n    function getKernelAppAddrNamespace() external pure returns (bytes32) { return KERNEL_APP_ADDR_NAMESPACE; }\n    function getKernelAppId() external pure returns (bytes32) { return KERNEL_CORE_APP_ID; }\n    function getDefaultACLAppId() external pure returns (bytes32) { return KERNEL_DEFAULT_ACL_APP_ID; }\n    function getDefaultVaultAppId() external pure returns (bytes32) { return KERNEL_DEFAULT_VAULT_APP_ID; }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}